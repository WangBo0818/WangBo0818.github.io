<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Talk is cheap.Show me the code.</title>
  
  <subtitle>hello world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wang818.top/"/>
  <updated>2020-04-08T08:43:28.630Z</updated>
  <id>http://wang818.top/</id>
  
  <author>
    <name>Wang Bo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020 春招历程及体会</title>
    <link href="http://wang818.top/2020/04/08/2020%20%E6%98%A5%E6%8B%9B%E5%8E%86%E7%A8%8B%E5%8F%8A%E4%BD%93%E4%BC%9A/"/>
    <id>http://wang818.top/2020/04/08/2020%20%E6%98%A5%E6%8B%9B%E5%8E%86%E7%A8%8B%E5%8F%8A%E4%BD%93%E4%BC%9A/</id>
    <published>2020-04-08T08:43:55.541Z</published>
    <updated>2020-04-08T08:43:28.630Z</updated>
    
    <content type="html"><![CDATA[<p>从三月初参加 21 届春招实习到现在也有一个多月了，在这个过程中有紧张兴奋、有惶惑茫然、有自我怀疑、有拿到 Offer 的那种喜悦，在春招的过程中有着以前从未有过的心路历程。目前已经拿到了心仪的 Offer，所以打算结束此次春招，也是时候来进行总结了。</p><p>这篇文章并不是分享我遇到的笔试、面试题，因为像牛客网上有很多的面经可供参考，我更多分享的是我这一个多月的体会、心路历程以及在笔试、面试过程中记忆深刻的地方和自己的不足以及未来要补充的地方。如果看到这篇文章的你正打算或将打算找实习，希望能够给你一些参考。</p><h4 id="找实习的途径"><a href="#找实习的途径" class="headerlink" title="找实习的途径"></a>找实习的途径</h4><ul><li><p>最好是能找学长学姐进行内推，这样不但能随时查看进度，学长学姐们也可以根据各自公司的技术栈帮你进行模拟面试</p></li><li><p>其次在牛客网或 GitHub 上找到内推帖和目标公司的在职员工，让他们帮忙内推。我的经验是不要害羞，有什么问题可以私发消息，他们人都很好</p></li><li><p>然后是去公司的招聘官网上投递简历</p></li><li><p>最后是去拉勾、Boss等招聘平台投递</p><h4 id="简历投递的顺序"><a href="#简历投递的顺序" class="headerlink" title="简历投递的顺序"></a>简历投递的顺序</h4><p>我最开始投的是阿里，第一次接到面试的也是阿里，当时紧张的连话都说不清楚，面试开始时的自我介绍都说的毫无逻辑，面试官人很好，一直温和说不要紧张，他没听清的也会耐心询问。关于这点我的建议是：</p></li><li><p>首先投递一些小型公司，积累一些面试经验，至少是在面试的过程中不会紧张，能够正确表达自己</p></li><li><p>然后是投递一些超出自己能力范围的一流大厂，这样可以了解大厂的面试流程及面试内容</p></li><li><p>最后才是投递自己的目标公司</p></li></ul><h4 id="面试知识点总结"><a href="#面试知识点总结" class="headerlink" title="面试知识点总结"></a>面试知识点总结</h4><ul><li><p>大部分面试题都是比较常规的，如 Java 基础、计算机网络、数据结构、操作系统、多线程、JVM，然后是问简历上的项目和技能清单相关的内容</p></li><li><p>我记忆最深刻的一道面试题是阿里二面时关于贪吃蛇的一道程序设计题，这题我当时答的很混乱，Java 是面向对象程序设计的语言，而我对面向对象设计的认识却是那么的浅显。下一阶段要着重于面向对象思维的培养</p></li><li><p>多线程相关记忆深刻的是使用三个线程顺序打印 1 到 100 的数字，这题我当时虽然有思路，但是答的也很混乱。对于多线程相关的知识，我了解的大多是理论知识，并没有进行实践，这也是下一阶段需要重点了解的知识</p></li><li><p>还有海量数据处理相关内容，如 TOP K 问题、海量数据查找、海量数据分区，这些都是我需要深入了解的点</p></li><li><p>项目相关的话，对于项目中的重难点以及可以进行优化的点一定要了解清楚，一部分面试官会偏向基础，另一部分面试官可能会偏向项目</p></li><li><p>关于情景设计题，如设计一个 Key-Value 数据结构、设计线程池等，可以参考 HashMap 和 Java 线程池的实现原理，这部分内容只能靠平时的积累，对容器、框架源码的理解，例如：给项目添加日志分析处理等可以通过 AOP 来实现，但是怎样实现就需要你对 AOP 有一定的了解</p></li><li><p>数据结构与算法及其重要，除了笔试必考这些以外，面试也会让你口撕算法，算法的话不能仅仅是给出答案，而是要给出更好的答案，要对时间复杂度和空间复杂度进行不断的优化。我这方面的知识也需要加强，我目前把剑指 Offer 编程题都刷了一遍，LeetCode 的话也做了 140 题，这可以给大家一个最低参考。个人认为至少要在 LeetCode 高质量的刷 200 题，弄懂这些题的多种解法及算法思路</p></li><li><p>数据库相关的点就是索引原理及其底层数据结构、SQL 执行过程、SQL 优化、事务等知识。但是对于大表拆分、大表优化等相关知识我还不是很了解，当问到这部分知识时我的回答都是分库分表，但是具体怎样实现却没有深入了解</p></li><li><p>框架相关的内容在这么多次的面试过程中问的都比较少，想 Spring 框架 的 AOP、IOC 等，像一个面试官所说的那样，框架只要想学都会</p><h4 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h4></li><li><p>三月的前两个星期，虽然投了一些企业但是只接到了寥寥无几的面试，当时一直处于自我怀疑中，觉得是不是自己太差了。然后我通过和学长学姐交流得知他们当时也是这种情况，如果说你和我遇到同样的情况，请静心等待开花结果的那天。我记忆很深刻的一句话是：<strong>你水平够了一次面试机会就够了，水平不够再多面试机会也没有用</strong>。我请学长学姐帮我修改简历，前前后后大改小改共有 10 次左右，热心的学长学姐也会帮我进行模拟面试，我自己也专注于知识点而不是处于是不是找不到实习的焦虑</p></li><li><p>三月中旬我拿到了第一个 Offer，此时焦虑的情绪就缓解了很多，可以更加专注的备战春招。我个人认为刚开始手里一定要有一个 Offer，这样情绪真的会好很多，不然真的感觉好压抑</p></li><li><p>到现在，我已经拿到了中意的 Offer，心情感到很放松。回顾过去一个多月真的是好累，这种累不是身体层面的，而是精神层面的。我不会忘记第一次接到面试电话时的紧张兴奋、第一次得知面试挂掉的失落、第一次接到 HR 电话的喜悦、第一次收到 Offer 确认函的那种单纯的快乐、拿到 Offer 一两天后的惶惑，这些经历和体会让我感觉成长了很多</p></li><li><p>我很喜欢滨崎步的歌曲 My All，她当时在演唱会唱完这首歌后说道：“当那天还未到来的时候，你要做的便是安心等待”。当你做到自己能做到最好后，剩下的便是等待，以此共勉</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4></li><li><p>在笔试、面试的过程中，我觉得最重要的就是真诚，会的好好回答，不会的说抱歉不会</p></li><li><p>要时刻保持学徒的勤奋，外面优秀的人真的太多了，想要和他们竞争，自己也要变得更加优秀</p></li><li><p>虽然我现阶段春招结束了，但路漫漫而修远，希望自己能够不断追寻</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从三月初参加 21 届春招实习到现在也有一个多月了，在这个过程中有紧张兴奋、有惶惑茫然、有自我怀疑、有拿到 Offer 的那种喜悦，在春招的过程中有着以前从未有过的心路历程。目前已经拿到了心仪的 Offer，所以打算结束此次春招，也是时候来进行总结了。&lt;/p&gt;
&lt;p&gt;这篇文
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络基础及 TCP、HTTP 协议详解</title>
    <link href="http://wang818.top/2020/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E5%8F%8A%20TCP%E3%80%81HTTP%20%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wang818.top/2020/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E5%8F%8A%20TCP%E3%80%81HTTP%20%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-15T15:33:41.323Z</published>
    <updated>2020-02-15T15:33:11.431Z</updated>
    
    <content type="html"><![CDATA[<p>“如果给我一个小时来解决一个问题，我会用五十五分钟来定义问题，剩下的五分钟用来解决问题”——爱因斯坦。</p><h2 id="为什么要学习计算机网络？"><a href="#为什么要学习计算机网络？" class="headerlink" title="为什么要学习计算机网络？"></a>为什么要学习计算机网络？</h2><p>从大背景来说，现在是数字化，网络化，信息化，是以网络为核心的时代。三网中，即电信网络、有线电视网和计算机网络，发展最快并起核心作用的是计算机网络。除此之外，对于计算机网络的研究，对于其他</p><p>从开发者的角度而言，计算机网络和数据结构与算法、操作系统、计算机组成原理等都是计算机系统的重要组成部分。另外，在开发过程中难免会进行一些抓包操作，这就需要对计算机网络有一定的认识。</p><h2 id="为什么计算机网络的体系结构选择分层设计？"><a href="#为什么计算机网络的体系结构选择分层设计？" class="headerlink" title="为什么计算机网络的体系结构选择分层设计？"></a>为什么计算机网络的体系结构选择分层设计？</h2><p>简单来说，凡是复杂的结构都需要分层。</p><p>网络协议分层，和计算机领域的其他分层，比如三层架构的分层，甚至非计算机领域比如政企业管理架构的分层，在本质上都是一样的。</p><p>分层的本质是通过分离关注点而让问题简单化。 当一个系统足够复杂时，通过聚合分为不同层次或不同模块， 每层或模块都是内聚的，对外屏蔽复杂性。 那么宏观上看去，管理和问题定位很容易到具体层次和模块。 然后层层递进，很容易定位问题。</p><p>分层式结构的优势：</p><ul><li>开发人员可以只关注整个结构中的其中某一层；</li><li>可以很容易的用新的实现来替换原有层次的实现；</li><li>可以降低层与层之间的依赖；</li><li>有利于标准化；</li><li>利于各层逻辑的复用。</li></ul><h2 id="为什么要使用网络协议？"><a href="#为什么要使用网络协议？" class="headerlink" title="为什么要使用网络协议？"></a>为什么要使用网络协议？</h2><p>我还记得第一次在显示器打印 “Hello World !” 时的激动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是一种协议，是开发者与计算机沟通的协议，只有通过这种协议，才能实现人机交互</p><p>通过计算机编程语言，你就可以让一台计算机完成你的指令</p><p>但是，要想打造互联网世界的通天塔，只教给一台机器做什么是不够的，你需要学会教给一大片机器做什么。这就需要网络协议。只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。</p><h2 id="计算机网络体系结构有几种分类？"><a href="#计算机网络体系结构有几种分类？" class="headerlink" title="计算机网络体系结构有几种分类？"></a>计算机网络体系结构有几种分类？</h2><p>计算机网络体系结构分为三种：</p><ul><li><strong>OSI 七层体系结构</strong>（概念清楚且理念完整，但是太复杂并且不使用，层与层之间有重叠的部分）<br><img src="https://img-blog.csdnimg.cn/20200211233219308.png" alt="OSI 七层体系结构"><br><img src="https://img-blog.csdnimg.cn/2020021123340389.png" alt="OSI 七层体系结构详情"></li><li><strong>TCP / IP 体系结构</strong>（包含了一系列构成互联网基础的网络协议，是 Internet 的核心协议，被广泛应用于局域网和广域网）<br><img src="https://img-blog.csdnimg.cn/20200211233513255.png" alt="TCP / IP 体系结构"><br><img src="https://img-blog.csdnimg.cn/20200211233548316.png" alt="TCP / IP 体系结构详情"></li><li><strong>五层体系结构</strong>（结合了以上两种结构的优点，目的是为了学习、讲解计算机网络原理）</li></ul><h2 id="HTTP、TCP、UDP-协议详解"><a href="#HTTP、TCP、UDP-协议详解" class="headerlink" title="HTTP、TCP、UDP 协议详解"></a>HTTP、TCP、UDP 协议详解</h2><h3 id="HTTP-（Hyper-Text-Transfer-Protocol），即超文本传输协议"><a href="#HTTP-（Hyper-Text-Transfer-Protocol），即超文本传输协议" class="headerlink" title="HTTP （Hyper Text Transfer Protocol），即超文本传输协议"></a>HTTP （Hyper Text Transfer Protocol），即超文本传输协议</h3><p>HTTP 属于应用层协议，其规定了应用进程间通信的规则。</p><h4 id="HTTP-协议的特点"><a href="#HTTP-协议的特点" class="headerlink" title="HTTP 协议的特点"></a>HTTP 协议的特点</h4><table><thead><tr><th>特点</th><th>具体描述</th></tr></thead><tbody><tr><td>传输效率高</td><td>在交换 HTTP 报文之前，不需要建立 HTTP 连接（无连接）；数据在传输的过程中，不保存任何历史及状态信息（无状态）</td></tr><tr><td>传输可靠性高</td><td>采用 TCP（见下文） 作为运输层协议，在交换报文之前，必须建立 TCP 连接</td></tr><tr><td>兼容性好</td><td>指出 B / S、C / S 模式</td></tr><tr><td>灵活性好</td><td>HTTP 允许传输任意类型的数据对象</td></tr></tbody></table><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p>HTTP 协议采用 <strong>请求</strong> / <strong>响应</strong> 的工作方式</p><p>具体工作方式如下：<br><img src="https://img-blog.csdnimg.cn/2020021423405549.png" alt="HTTP 协议工作流程"></p><h4 id="HTTP-报文详解"><a href="#HTTP-报文详解" class="headerlink" title="HTTP 报文详解"></a>HTTP 报文详解</h4><p>HTTP 在应用层交互数据的方式是报文，而报文又分为<strong>请求报文</strong>和<strong>响应报文</strong>，分别用于发送请求和响应请求</p><p>具体可参考<a href="https://www.jianshu.com/p/a6d086a3997d" target="_blank" rel="noopener">https://www.jianshu.com/p/a6d086a3997d</a> 以及《图解 HTTP》</p><h3 id="TCP-（Transmission-Control-Protocol），即传输控制协议"><a href="#TCP-（Transmission-Control-Protocol），即传输控制协议" class="headerlink" title="TCP （Transmission Control Protocol），即传输控制协议"></a>TCP （Transmission Control Protocol），即传输控制协议</h3><p> TCP 协议属于传输层协议，基于 TCP 协议的应用层协议有 HTTP（万维网）、SMTP（电子邮件）、FTP（文件传输）、TELNET（远程中断介入）、POP3（邮局）</p><h4 id="TCP-协议的特点："><a href="#TCP-协议的特点：" class="headerlink" title="TCP 协议的特点："></a>TCP 协议的特点：</h4><table><thead><tr><th>特点</th><th>具体描述</th></tr></thead><tbody><tr><td>面向连接</td><td>使用 TCP 传输数据前，必须先建立 TCP 连接；传输完成后再释放连接（类似于打电话）</td></tr><tr><td>全双工通信</td><td>建立 TCP 连接后，通信双方都能发送数据</td></tr><tr><td>可靠性</td><td>建立 TCP 连接后传输的数据：不丢失、无差错、不重复且按序到达</td></tr><tr><td>面向字节流</td><td>数据以流的形式进行传输</td></tr></tbody></table><h4 id="报文段格式："><a href="#报文段格式：" class="headerlink" title="报文段格式："></a>报文段格式：</h4><p>TCP 虽然面向字节流，但是其传输的数据单元是<strong>报文段</strong>，而报文段又分<strong>首部</strong>和<strong>数据</strong>两部分。TCP 的全部功能都体现在它首部中各字段的作用，因此 TCP 的重点就在于其报文段的首部</p><p>报文段的首部前 20 个字符固定、后面有 4n 个字节是根据需要而添加的选项，故 TCP 首部的最小长度为 20 字节<br><img src="https://img-blog.csdnimg.cn/20200212002159996.png" alt="TCP 报文段首部"><br><img src="https://img-blog.csdnimg.cn/20200212002250421.png" alt="TCP 报文段首部详情"></p><h4 id="TCP-建立连接过程："><a href="#TCP-建立连接过程：" class="headerlink" title="TCP 建立连接过程："></a>TCP 建立连接过程：</h4><p>TCP 建立连接需要进行三次握手，在三次握手期间，任意一次未收到对方的回复，都会重新发送。在成功进行 TCP 的三次握手后，就建立起 TCP 连接，即可方向传输数据。<br><img src="https://img-blog.csdnimg.cn/20200212222404530.png" alt="TCP 建立连接"></p><h4 id="TCP-需三次握手才能建立连接的原因："><a href="#TCP-需三次握手才能建立连接的原因：" class="headerlink" title="TCP 需三次握手才能建立连接的原因："></a>TCP 需三次握手才能建立连接的原因：</h4><p>在客户端向服务器发送的第一个 TCP 连接请求时，若因为网络等原因滞留了，从而导致延误到 TCP 连接释放后的某个时间才到达服务器，此时，由于服务器不知道这是一个已失效的连接，因此如果没有三次握手，这时就会重新建立一个 TCP 连接，而客户端却不会向服务器发送数据，这就导致了资源的浪费。</p><p>为了解决以上问题，TCP 采用三次握手的方式建立连接，其中关键的是第三次握手，服务器端若收不到客户端的确认信息（第三次握手），就知道客户端无连接请求，就不会建立 TCP 连接，从而避免了资源浪费 </p><h4 id="TCP-释放连接过程："><a href="#TCP-释放连接过程：" class="headerlink" title="TCP 释放连接过程："></a>TCP 释放连接过程：</h4><p>在通信结束后，需要四次挥手来释放连接<br><img src="https://img-blog.csdnimg.cn/20200212224723909.png" alt="TCP 四次挥手释放连接"></p><h5 id="TCP-需四次挥手才能释放连接的原因："><a href="#TCP-需四次挥手才能释放连接的原因：" class="headerlink" title="TCP 需四次挥手才能释放连接的原因："></a>TCP 需四次挥手才能释放连接的原因：</h5><p>TCP 连接采用的是全双工通信方式，即双方都可以传送、接收数据。因此需要四次挥手来确保双向断开，从而是 TCP 连接处于关闭状态，而半办关闭状态（服务器端可以向客户端传送数据）</p><h5 id="客户端关闭连接前为何要等待-2MSL-时间（即-TIME-WITE-状态的作用）？"><a href="#客户端关闭连接前为何要等待-2MSL-时间（即-TIME-WITE-状态的作用）？" class="headerlink" title="客户端关闭连接前为何要等待 2MSL 时间（即 TIME_WITE 状态的作用）？"></a>客户端关闭连接前为何要等待 2MSL 时间（即 TIME_WITE 状态的作用）？</h5><p>MSL（Maximum Segment Lifetime）最长报文段寿命。为了保证客户端发送的最后一个确认释放连接报文能正确到达服务器，从而使服务机能够正常释放连接</p><p>除此之外，在客户端发送了最后一个确认释放连接报文后，再经过 2MSL 时间，则可以使本连接持续时间内锁所产生的所有报文段都从网络中消失，即在下一个连接中就不会出现已经失效的连接请求报文</p><h4 id="TCP-协议的无差错传输"><a href="#TCP-协议的无差错传输" class="headerlink" title="TCP 协议的无差错传输"></a>TCP 协议的无差错传输</h4><p>无差错传输，即传输信道不出差错、发动 &amp; 传输数据的速率匹配</p><h5 id="窗口滑动协议"><a href="#窗口滑动协议" class="headerlink" title="窗口滑动协议"></a>窗口滑动协议</h5><p>实现无差错传输的基础是滑动窗口协议<br><img src="https://img-blog.csdnimg.cn/20200212231716535.png" alt="窗口协议"></p><h5 id="滑动窗口协议的重要特性："><a href="#滑动窗口协议的重要特性：" class="headerlink" title="滑动窗口协议的重要特性："></a>滑动窗口协议的重要特性：</h5><ul><li><p>只有接收窗口向前滑动、接收方发送了确认帧时，发送窗口才有可能（只有发送方收到确认帧才是一定）向前滑动</p></li><li><p><strong>停止-等待协议</strong>、<strong>后退N帧协议</strong>、<strong>选择重传协议</strong>只是在发送窗口大小和接收窗口大小上有所差别</p></li><li><p>当接收窗口的大小为1时，可保证帧有序接收</p></li><li><p>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意要与TCP的滑动窗口协议区别）</p><p>其中:</p></li><li><p>停止等待协议：发送窗口大小=1，接收窗口大小=1；即 单帧滑动窗口 等于 停止-等待协议</p></li><li><p>后退N帧协议：发送窗口大小&gt;1，接收窗口大小=1。</p></li><li><p>选择重传协议：发送窗口大小&gt;1，接收窗口大小&gt;1。</p></li></ul><h5 id="实现无差错传输的解决方案："><a href="#实现无差错传输的解决方案：" class="headerlink" title="实现无差错传输的解决方案："></a>实现无差错传输的解决方案：</h5><p>核心思想：采用可靠的传输协议，使得</p><ol><li>出现差错时，让发送方重传差错数据，即出错重传</li><li>当接收方来不及接收数据时，可通知发送方降低发送数据的速率，及速度匹配</li></ol><p>针对以上问题，分别采用的解决方案是：自动重传协议以及流量控制 &amp; 拥蹙控制协议。</p><p>具体可参照<a href="https://www.jianshu.com/p/65605622234b" target="_blank" rel="noopener">https://www.jianshu.com/p/65605622234b</a></p><h3 id="UDP-（User-Datagram-Protocol），即用户数据报协议"><a href="#UDP-（User-Datagram-Protocol），即用户数据报协议" class="headerlink" title="UDP （User Datagram Protocol），即用户数据报协议"></a>UDP （User Datagram Protocol），即用户数据报协议</h3><p>UDP 协议属于传输层通信协议，基于 UDP 的应用层协议有 DNS（域名系统） 协议、FTP（文件传输）协议、SNMP（网络管理）协议、NFS（远程文件服务器）协议</p><h4 id="UDP-协议的特点："><a href="#UDP-协议的特点：" class="headerlink" title="UDP 协议的特点："></a>UDP 协议的特点：</h4><table><thead><tr><th>特点</th><th>具体描述</th></tr></thead><tbody><tr><td>无连接</td><td>使用UDP 传输数据前，不需要建立连接（类似发短信）</td></tr><tr><td>不可靠</td><td>UDP 的数据包发送后，不会管是否到达接收方（所以可能出现丢包现象）</td></tr><tr><td>面向报文</td><td>数据以用户数据报的形式传输（UDP 数据报文无长度限制，并且是一次发送，不会像 TCP 进行拆分）</td></tr><tr><td>无拥蹙控制</td><td>由于是不可靠传输，所以不管是否达到，及不需要拥蹙控制</td></tr></tbody></table><p>UDP 传输数据快，但是数据容易丢失，特别是在网络差的情况下</p><h4 id="用户数据报格式："><a href="#用户数据报格式：" class="headerlink" title="用户数据报格式："></a>用户数据报格式：</h4><p>UDP 的用户数据报由首部和数据两部分组成，和 TCP 一样，报文的重点在于首部（8 字节）<br><img src="https://img-blog.csdnimg.cn/20200212235122156.png" alt="UDP首部"><br><img src="https://img-blog.csdnimg.cn/20200212235222233.png" alt="详情"></p><h4 id="TCP、UDP-协议的区别："><a href="#TCP、UDP-协议的区别：" class="headerlink" title="TCP、UDP 协议的区别："></a>TCP、UDP 协议的区别：</h4><p><img src="https://img-blog.csdnimg.cn/2020021223534322.png" alt="TCP/UDP 协议的区别"><br>参考资料：<br><a href="https://www.jianshu.com/p/a6d086a3997d" target="_blank" rel="noopener">https://www.jianshu.com/p/a6d086a3997d</a><br><a href="https://www.jianshu.com/p/45d27f3e1196" target="_blank" rel="noopener">https://www.jianshu.com/p/45d27f3e1196</a><br>《图解 HTTP》<br>《计算机网络》（谢希仁著）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“如果给我一个小时来解决一个问题，我会用五十五分钟来定义问题，剩下的五分钟用来解决问题”——爱因斯坦。&lt;/p&gt;
&lt;h2 id=&quot;为什么要学习计算机网络？&quot;&gt;&lt;a href=&quot;#为什么要学习计算机网络？&quot; class=&quot;headerlink&quot; title=&quot;为什么要学习计算机
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java 多线程编程思维导图</title>
    <link href="http://wang818.top/2020/01/30/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://wang818.top/2020/01/30/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</id>
    <published>2020-01-30T06:10:38.027Z</published>
    <updated>2020-01-30T06:10:10.858Z</updated>
    
    <content type="html"><![CDATA[<p>参照 《Java 多线程编程实战指南》（黄文海 / 著）画的，以便随时复习相关内容。<br><img src="https://img-blog.csdnimg.cn/20200130140230856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="走进 Java 世界中的线程"><br><img src="https://img-blog.csdnimg.cn/20200130140308323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="多线程编程中的目标与挑战"><br><img src="https://img-blog.csdnimg.cn/20200130140336471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="Java 线程同步机制"><br><img src="https://img-blog.csdnimg.cn/20200130140439709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="在实践中运用多线程"><br><img src="https://img-blog.csdnimg.cn/20200130140518884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="线程间协作"><br><img src="https://img-blog.csdnimg.cn/20200130140549879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="线程安全设计"><br><img src="https://img-blog.csdnimg.cn/20200130140607624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="线程的活性故障"><br><img src="https://img-blog.csdnimg.cn/202001301406438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="线程管理"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参照 《Java 多线程编程实战指南》（黄文海 / 著）画的，以便随时复习相关内容。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200130140230856.png?x-oss-process=image/watermark,t
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vim 的前世今生</title>
    <link href="http://wang818.top/2020/01/21/Vim%20%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://wang818.top/2020/01/21/Vim%20%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2020-01-21T11:47:23.539Z</published>
    <updated>2020-01-21T11:46:14.031Z</updated>
    
    <content type="html"><![CDATA[<p>每个开发者都有着自己情有独钟的文本编辑器，我 Windows 系统下用的是 Notepad++，在 Linux 系统下搭建、部署服务器的时候习惯使用 Vi 或 Vim 编辑器。最近在浏览耗子哥的博客的时候，发现他对 Vim 的喜爱远超其他文本编辑器，并且包括 Facebook 在内的一些大型网站，当按下 j 键时，会向下滚动，而当按下 k 键时，会向上滚动—–这意味着 Vim 通过数字文化传播达到了难以想象的高水准。</p><p>然而，Vim 像是谜一样的存在，Vim 没有明显的发起人。尽管 Vim 很常见也很重要，但是似乎没有任何委员会或组织为 Vim 做出决策。github 上 Vim 也只有两个开发者，而且Pull Requests 也很少。<br><img src="https://img-blog.csdnimg.cn/20200115203941583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="Vim 的开发者"><br>这更加激起了我对 Vim 的兴趣，于是查找了一些相关资料。</p><p>了解 Vim 的历史，一个很好地资料是Vim 创始人 Bram Moolenaar 在 VimConf 2018 上的专题演讲，他在演讲中回顾了 Vim 的发展以及 Vim 即将添加的一些新特性。YouTube 上有该<a href="https://www.youtube.com/watch?v=ES1L2SPgIDI" target="_blank" rel="noopener">演讲视频</a>，哔哩哔哩上有<a href="https://www.bilibili.com/video/av79242778" target="_blank" rel="noopener">字幕版</a>的。</p><p>简单来说，Vim 于 1991 年由 Bram 发布，最初 Vim 模仿了 Vi 编辑器的特性，后面加以扩展，逐步添加了很多新功能。今年距离 Vim 首次发布已经快要 30 年了，Vim 这个强大的编辑器仍然存在并且被许多人所使用和讨论，这也从侧面说明了 Vim 的魅力。刚开始，Vim 完全由 Bram 一个人开发维护，后面有开发者不断加入 Vim 的开发，并把 Vim 移植到了不同的系统平台上。有一段时间，Bram 甚至辞去了工作，全力投入到 Vim 的开发中，靠着网友的捐助维持基本生活。2006 年 Bram 加入了 Google 位于苏黎世的分部，Google 出于对 Bram 的尊重以及对开源文化的认同，同意 Bram 每周可以花 20% 的工作时间用于和 Vim 相关的工作，谷歌真是一家开明的公司，我本有心向谷歌，奈何配不上啊。</p><p><strong>具体来说，得从 1966 年开始讲起。</strong></p><h2 id="Ken-Thompson-创建了行编辑器"><a href="#Ken-Thompson-创建了行编辑器" class="headerlink" title="Ken Thompson 创建了行编辑器"></a>Ken Thompson 创建了行编辑器</h2><p>1966 年，贝尔实验室聘用了 Ken Thompson 。Thompson 刚刚在加州大学伯克利分校完成了电气工程和计算机科学的硕士学位。在伯克利他使用一个名为 QED 的文本编辑器，该编辑器在 1965 到 1966 年间被开发用于伯克利分时系统。</p><p>Thompson 在进入实验室后，Thompson 和贝尔实验室资深研究员 Dennis Ritchie（c 语言之父，Unix 之父），开始怀念分时系统所提供的“交互式计算的感觉”，并着手创建他们自己的版本，该版本最终发展成为 Unix。</p><p>1969 年 8 月，Thompson “给操作系统、shell、编辑器和汇编程序分别分配了一个星期”，将新系统的基本组件组合在一起。（这样我想起了开发 linux 内核和 git 的 Linus TechTips，都是大神） </p><p>这个编辑器被称为 ed 。它是基于 QED 的，但并不完全是 QED 的复现。<br><img src="https://img-blog.csdnimg.cn/20200120210953449.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="thompson 和 dennis ritchie 合照"></p><h2 id="Bill-Joy-创建了文本编辑器"><a href="#Bill-Joy-创建了文本编辑器" class="headerlink" title="Bill Joy 创建了文本编辑器"></a>Bill Joy 创建了文本编辑器</h2><p>对 Thompson 和 Ritchie 来说， ed 已经足够好了。但是其他人则认为它很难用，而且它作为一个淋漓尽致地表现 Unix 对新手敌意的例子而臭名昭著。在 1975 年，一个名叫 George Coulouris 的人在伦敦玛丽皇后学院的 Unix 系统上开发了一个改进版 ed 。<br><img src="https://img-blog.csdnimg.cn/20200121192855443.jpg" alt="George Coulouris"><br>当时是伯克利软件发行公司（BSD）的研究生的 Bill Joy 以 Coulouris 的源代码为基础，为扩展 ed 建立了一个名为 ex 的改进版 ed。</p><p>1979 年的第 2 版 BSD 引入了一个名为 vi 的可执行文件，它只在可视模式下打开 ex 。这也就后来的 Vi。<br><img src="https://img-blog.csdnimg.cn/20200121192710848.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="Bill Joy"></p><h2 id="Bram-Moolenaar-创建了-Vim"><a href="#Bram-Moolenaar-创建了-Vim" class="headerlink" title="Bram Moolenaar 创建了 Vim"></a>Bram Moolenaar 创建了 Vim</h2><p>“Vim”现在是“改进版 Vi”的缩写，而最初代表的是“模拟版 Vi”。和其他许多“vi克隆版本”一样，Vim 始于在一个无法使用 vi 的平台上复现 vi 的一个尝试。在荷兰 Venlo 一家影印公司工作的软件工程师 Bram Moolenaar 想要为他全新的 Amiga 2000 准备一款类似于 vi 的编辑器。Moolenaar 已经习惯了在大学时使用的 Unix 系统上的 vi ，当时他已经对vi了如指掌。10 所以在 1988 年，Moolenaar 使用当时的 STEVIE vi克隆版本开始在 Vim 上工作。<br><img src="https://img-blog.csdnimg.cn/20200121193612408.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="Bram Moolenaar "></p><h2 id="Vim-开发模式与弊端"><a href="#Vim-开发模式与弊端" class="headerlink" title="Vim 开发模式与弊端"></a>Vim 开发模式与弊端</h2><p>Vim 最初开发的年代，虽然国外已经兴起了开源运动，但是开源项目的组织与运行还不像现在这样方便，Git 和 GitHub 要在十几年后才会出现。其他开发者向 Bram 贡献 Vim 源代码的方式是通过邮件，向 Bram 提交 patch，如果 Bram 觉得这个 patch 不错，就会把 patch 加入到 Vim 的源代码中。20 多年过去了，开源项目的协作方式由于 Git 和 GitHub 的出现发生很大变化。很多顶级开源项目都选择使用 GitHub 进行代码的开发和管理，开发者通过 Git 提交 pull request 方式贡献自己的代码，如果项目的维护者觉得代码的质量 OK，就会合并这个请求，将代码并入主线代码中。</p><p>并且对于大多数用户来说，Vim有着一个比较陡峭的学习曲线。这意味着开始学习的时候可能会进展缓慢，掌握一些基本操作之后，才能大幅度提高编辑效率。</p><p>参考资料<br><a href="https://jdhao.github.io/2020/01/12/vim_nvim_history_development/" target="_blank" rel="noopener">https://jdhao.github.io/2020/01/12/vim_nvim_history_development/</a><br><a href="https://zh.wikipedia.org/zh-hans/Vim" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/Vim</a><br><a href="https://www.oschina.net/translate/where-vim-came-from?lang=eng" target="_blank" rel="noopener">https://www.oschina.net/translate/where-vim-came-from?lang=eng</a><br><a href="https://segmentfault.com/a/1190000016598055" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016598055</a><br><a href="https://www.youtube.com/watch?v=ES1L2SPgIDI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ES1L2SPgIDI</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每个开发者都有着自己情有独钟的文本编辑器，我 Windows 系统下用的是 Notepad++，在 Linux 系统下搭建、部署服务器的时候习惯使用 Vi 或 Vim 编辑器。最近在浏览耗子哥的博客的时候，发现他对 Vim 的喜爱远超其他文本编辑器，并且包括 Faceboo
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从 LeetCode_41 缺失的第一个正数到八种排序算法</title>
    <link href="http://wang818.top/2020/01/17/%E4%BB%8E%20LeetCode_41%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0%E5%88%B0%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://wang818.top/2020/01/17/%E4%BB%8E%20LeetCode_41%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0%E5%88%B0%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-01-17T13:04:24.854Z</published>
    <updated>2020-01-17T13:03:47.337Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">LeetCode 41. 缺失的第一个正数</a>，这题在 LeetCode 上虽然属于困难题，但是如果不是因为题目要求算法的时间复杂度应为O(n)，那么这题只能算作简单题。我的解法是：首先将给定数组排序，然后从最小的正数 1 开始判断。在提交前我以为算法的时间复杂度会很差，这时候奇怪的事情发生了。具体代码及运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int firstMissingPositive(int[] nums) &#123;</span><br><span class="line">        if (nums &#x3D;&#x3D; null || nums.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int target &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if(nums[i] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                target +&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200113185912195.png" alt="算法运行结果"><br>我对这个 1ms 很是好奇，虽然 LeetCode 上的每次提交结果都会有一定的差异，但经过我多次提交后，执行用时基本还是 1ms。</p><p>从代码分析来看，算法的时间复杂度就是给数组排序（Arrays.sort() 方法）以及数组的一次遍历（O(n)）。所以肯定是 Arrays.sort() 方法的时间复杂度接近 O(n)。</p><p>于是我去看了 Arrays.sort() 方法的实现，Java 主要排序方法的 java.util.Arrays.sort()，对于基本数据类型使用三向切分的快速排序，对于引用类型使用归并排序。而三向切分的快速排序的时间复杂度为 N ~ NlogN，很接近 O(n)。</p><p>因为之前我对排序算法只了解选择排序、冒泡排序、插入排序、归并排序、希尔排序，这些算法的时间复杂度没有一个比得上三向切分的快速排序。所以我就重新对我会的排序算法进行整理以及补充不了解的排序算法，如：快速排序、堆排序等。</p><p>在找相关资料的过程中，看到了一篇对排序算法总结的很好的文章。<a href="https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F</a></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p><p>选择排序需要 ~N2/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p><p>而选择排序又是<strong>不稳定</strong>的算法，因此不推荐使用选择排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void sort(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到最小元素的下标</span><br><span class="line">            int min &#x3D; i;</span><br><span class="line">            for(int j &#x3D; i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                if(nums[j] &lt; nums[min]) &#123;</span><br><span class="line">                    min &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 将最小元素与第一个元素交换位置</span><br><span class="line">            int tmp &#x3D; nums[i];</span><br><span class="line">            nums[i] &#x3D; nums[min];</span><br><span class="line">            nums[min] &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。</p><p>在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。</p><p>冒泡排序的时间复杂度和选择排序差不多，但是冒泡排序是<strong>稳定</strong>的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void sort2(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">                if (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                   int tmp &#x3D; nums[i];</span><br><span class="line">                    nums[i] &#x3D; nums[j];</span><br><span class="line">                    nums[j] &#x3D; tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序</p><p>插入排序是<strong>稳定</strong>的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void sort3(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i; j &gt; 0; j--) &#123;</span><br><span class="line">                if (nums[j] &lt; nums[j - 1]) &#123;</span><br><span class="line">                    int tmp &#x3D; nums[j];</span><br><span class="line">                    nums[j] &#x3D; nums[j - 1];</span><br><span class="line">                    nums[j - 1] &#x3D; tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”</p><p>关于希尔排序的基本思想请参考其他资料，如：严蔚敏老师的《数据结构》（我们学校讲数据结构和基本算法就是用的这本书）</p><p>希尔排序是<strong>不稳定</strong>的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void sort4(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        &#x2F;&#x2F; 初始化步长，并且最后一步的步长也必须是 1</span><br><span class="line">        int h &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 确定最大步长</span><br><span class="line">        while (h &lt; n &#x2F; 3) &#123;</span><br><span class="line">            h &#x3D; 3 * h + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (h &gt;&#x3D; 1) &#123;</span><br><span class="line">            for (int i &#x3D; h; i &lt; n; i++) &#123;</span><br><span class="line">                for (int j &#x3D; i; j &gt;&#x3D; h; j -&#x3D; h) &#123;</span><br><span class="line">                    if (nums[j] &lt; nums[j - h]) &#123;</span><br><span class="line">                        int tmp &#x3D; nums[j];</span><br><span class="line">                        nums[j] &#x3D; nums[j - h];</span><br><span class="line">                        nums[j - h] &#x3D; tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h &#x3D; h &#x2F; 3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并</p><p>归并排序的步骤：</p><ul><li>第一步：申请空间，使其大小为两个已经排序序列的长度之和，该空间用来存放合并后的序列</li><li>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>第三步：比较两个指针所指向的元素，选择相对小的元素放入合并空间，并移动指针到下一个位置</li><li>重复步骤三直到某一指针超出序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ul><p>归并排序是<strong>稳定</strong>的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private void mergeSort(int[] nums, int left, int right) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果只有一个元素，就不要排序了</span><br><span class="line">        if (left &#x3D;&#x3D; right) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            &#x2F;&#x2F; 取中间的数进行拆分</span><br><span class="line">            int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 左边的数不断进行拆分</span><br><span class="line">            mergeSort(nums, left, mid);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 右边的数不断进行拆分</span><br><span class="line">            mergeSort(nums, mid + 1, right);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;合并</span><br><span class="line">            merge(nums, left, mid + 1, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void merge(int[] nums, int left, int mid, int right) &#123;</span><br><span class="line">        &#x2F;&#x2F; 左边数组的大小</span><br><span class="line">        int[] leftArr &#x3D; new int[mid - left];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 右边数组的大小</span><br><span class="line">        int[] rightArr &#x3D; new int[right - mid + 1];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 往这两个数组中填充数据</span><br><span class="line">        for (int i &#x3D; left; i &lt; mid; i++) &#123;</span><br><span class="line">            leftArr[i - left] &#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; mid; i &lt;&#x3D; right; i++) &#123;</span><br><span class="line">            rightArr[i - mid] &#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 两个指向 leftArr 和 rightArr 初始位置的指针</span><br><span class="line">        int i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 指向 nums 数组的第一个元素</span><br><span class="line">        int k &#x3D; left;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 比较两个数组的元素值，哪个小，就把哪个往 nums 数组上放</span><br><span class="line">        while (i &lt; leftArr.length &amp;&amp; j &lt; rightArr.length) &#123;</span><br><span class="line">            &#x2F;&#x2F; 谁比较小，谁将元素放入大数组中，并移动指针，继续比较下一个；等于的情况是保持稳定</span><br><span class="line">            if (leftArr[i] &lt;&#x3D; rightArr[j]) &#123;</span><br><span class="line">                nums[k] &#x3D; leftArr[i];</span><br><span class="line">                i++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                nums[k] &#x3D; rightArr[j];</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span><br><span class="line">        while (i &lt; leftArr.length) &#123;</span><br><span class="line">            nums[k] &#x3D; leftArr[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span><br><span class="line">        while (j &lt; rightArr.length) &#123;</span><br><span class="line">            nums[k] &#x3D; rightArr[j];</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>快速排序是<strong>不稳定</strong>的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private void quickSort(int[] nums, int left, int right) &#123;</span><br><span class="line">        int i &#x3D; left;</span><br><span class="line">        int j &#x3D; right;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 快速排序中的支点，即该支点左边的元素都比右边的元素要小</span><br><span class="line">        int pivot &#x3D; nums[(left + right) &#x2F; 2];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 左右两端开始扫描</span><br><span class="line">        while (i &lt;&#x3D; j) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 寻找直到比支点大的数</span><br><span class="line">            while (pivot &gt; nums[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 寻找直到比支点小的数</span><br><span class="line">            while (pivot &lt; nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 此时已经分别找到了比支点小的数（右边），以及比支点大的数（左边），将它们进行交换</span><br><span class="line">            if (i &lt;&#x3D; j) &#123;</span><br><span class="line">                int tmp &#x3D; nums[i];</span><br><span class="line">                nums[i] &#x3D; nums[j];</span><br><span class="line">                nums[j] &#x3D; tmp;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 上面的 while 循环保证了第一趟排序支点的左边比支点小，支点的右边比支点大了</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; &quot;左边&quot;继续排序，直到左边只剩下一个数（递归出口）</span><br><span class="line">        if (left &lt; j) &#123;</span><br><span class="line">            quickSort(nums, left, j);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; &quot;右边&quot;继续排序，直到右边只剩下一个数（递归出口）</span><br><span class="line">        if (i &lt; right) &#123;</span><br><span class="line">            quickSort(nums, i, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="三向切分快速排序"><a href="#三向切分快速排序" class="headerlink" title="三向切分快速排序"></a>三向切分快速排序</h2><p>三向切分快速排序是快速排序的一种优化算法之一。对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。三向切分快速排序对于有大量重复元素的随机数组可以再线性时间内完成排序</p><p>三向切分快速排序是<strong>不稳定</strong>的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void ThreeWayQuickSort(int[] nums, int left, int right) &#123;</span><br><span class="line">        if (right &lt;&#x3D; left) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D; left, j &#x3D; right;</span><br><span class="line">        int k &#x3D; left + 1;</span><br><span class="line">        int pivot &#x3D;  nums[left];</span><br><span class="line">        while (k &lt;&#x3D; j) &#123;</span><br><span class="line">            if (nums[k] &lt; pivot) &#123;</span><br><span class="line">                int tmp &#x3D; nums[i];</span><br><span class="line">                nums[i] &#x3D; nums[k];</span><br><span class="line">                nums[k] &#x3D; tmp;</span><br><span class="line">                i++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;else if (nums[k] &gt; pivot) &#123;</span><br><span class="line">                int tmp &#x3D; nums[k];</span><br><span class="line">                nums[k] &#x3D; nums[j];</span><br><span class="line">                nums[j] &#x3D; tmp;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ThreeWayQuickSort(nums, left, i - 1);</span><br><span class="line">        ThreeWayQuickSort(nums, j + 1, right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。</p><ul><li><p>第一步：构建堆<br>  无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。</p></li><li><p>第二步：交换堆顶元素与最后一个元素，交换之后需要进行下沉操作维持堆的有序状态。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void heapSort(int []nums)&#123;</span><br><span class="line">        int last &#x3D; nums.length - 1;</span><br><span class="line">        &#x2F;&#x2F;N构建大根堆</span><br><span class="line">        &#x2F;&#x2F;从倒数第二层开始</span><br><span class="line">        for (int i &#x3D; nums.length &#x2F;2 - 1 ; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">            heapIfy(nums, i, last);</span><br><span class="line">        &#125;</span><br><span class="line">        while (last &gt;&#x3D; 1)&#123;</span><br><span class="line">            swap(nums,0,last--);</span><br><span class="line">            heapIfy(nums,0, last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;i 大根堆调整</span><br><span class="line">    public void heapIfy(int[] nums,int i,int last)&#123;</span><br><span class="line">        &#x2F;&#x2F;判断有没有子节点（左孩子）</span><br><span class="line">        int left &#x3D; i * 2 + 1;</span><br><span class="line">        while (left &lt;&#x3D; last)&#123;</span><br><span class="line">            int right &#x3D; left + 1;</span><br><span class="line">            &#x2F;&#x2F;左右节点最大值</span><br><span class="line">            int larger &#x3D; right &lt;&#x3D; last &amp;&amp; nums[right] &gt; nums[left] ? right : left;</span><br><span class="line">            if(nums[larger] &gt; nums[i])&#123;</span><br><span class="line">                swap(nums, larger, i);</span><br><span class="line">                i &#x3D; larger;</span><br><span class="line">                left &#x3D; larger * 2 + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void  swap(int []nums,int a,int b)&#123;</span><br><span class="line">        int tmp &#x3D; nums[a];</span><br><span class="line">        nums[a] &#x3D; nums[b];</span><br><span class="line">        nums[b] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>堆排序是<strong>不稳定</strong>的</p><h2 id="排序算法的比较"><a href="#排序算法的比较" class="headerlink" title="排序算法的比较"></a>排序算法的比较</h2><p><img src="https://img-blog.csdnimg.cn/20200117205926813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="排序算法的比较"></p><p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/first-missing-positive/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 41. 缺失的第一个正数&lt;/a&gt;，这题在 LeetCode 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>源码分析之HashMap的底层实现</title>
    <link href="http://wang818.top/2020/01/13/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wang818.top/2020/01/13/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-01-13T02:09:55.223Z</published>
    <updated>2020-01-13T02:09:45.602Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap 是 java 开发中使用频率最高的用于映射（键值对）处理的数据类型。随着JDK 版本的的更新，JDK1.8 对HashMap 底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。于是结合JDK1.7 和JDK1.8 两个目前主流的JDK版本的区别，探讨HashMap 的底层实现和功能原理。</p><p> 在JDK1.8 之前，HashMap 的底层是数组和链表结合使用。HashMap 通过key 的hashCode 经过扰动函数处理之后得到hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>而所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h;</span><br><span class="line">      <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">      <span class="comment">// ^ ：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>JDK 1.7 HashMap 的 hash 方法源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两者之间的hash 方法，原理大致相同，只是JDK 1.8 进行了一些简化。由源码可知，JDK 1.8 hash 方法的性能会高于JDK 1.7 的。</p><p>关于两者之间性能的对比，知乎上的美团技术团队在hash 较为均匀和hash 极不均匀两种情况下进行了性能测试，结果如下：</p><ul><li><p>hash 较为均匀<br>  <img src="https://img-blog.csdnimg.cn/20191105213211189.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面是Hash不均匀的的情况。</p></li><li><p>hash 极不均匀<br>  <img src="https://img-blog.csdnimg.cn/20191105213354667.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p></li></ul><p>关于两者性能差距的原因除了JDK1.8 的hash 方法性能高之外，JDK1.8及之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。而JDK1.7 则是使用拉链法来解决哈希冲突。</p><p> <strong>HashMap 的存储结构</strong><br>从 HashMap 的存储结构的实现上看，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。由源码可知，HashMap类中有一个非常重要的字段，即Node[] table，即哈希桶数组，它是一个Node 数组。下面是Node[JDK1.8] 的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。</p><p>当调用map.put() 方法时，系统将根据Key 的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash 算法的后两步运算（高位运算和取模运算）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p><p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。好的hash 算法和扩容机制可以减小map 的碰撞概率并且使哈希桶数组（Node[] table）占用的空间少。</p><p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line">  <span class="keyword">int</span> modCount;  <span class="comment">// 记录HashMap 内部结构发生变化（例如put，修改key对应的值不算）的次数</span></span><br><span class="line">  <span class="keyword">int</span> size;<span class="comment">// HashMap 中实际存在的键值对数量</span></span><br></pre></td></tr></table></figure><p>Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。由公式可知，负载因子（loadFactor）越大，所能容纳的最大键值对数越多。（不建议修改，在某些特殊情况下可以考虑修改）</p><p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><p><strong>HashMap 中的方法实现</strong><br>HashMap 的内部功能实现很多，以下是从根据Key 获取哈希桶数组索引位置、put 方法的源码、扩容过程等代表性较强的点进行分析。</p><ul><li>确定哈希桶索引数组位置<br>  不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。HashMap 的数据结构是数组和链表，所以我们希望HashMap 里面的元素分布的尽量均匀，最好使每个位置上的元素只有一个，这样当我们使用hash 算法求位置的时候，就能快速得到，而不需要去遍历链表。HashMap 定位数组索引位置，直接决定了hash方法的离散性能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知，hash 算法的本质就是三步：取Key 的hashCode 值、高位运算、取模运算。<br>关于hash 算法的具体细节实现，大家有兴趣可以自己对着源码查询相关资料。</p><ul><li>分析HashMap 的 put 方法<br>  JDK1.8HashMap的put方法源码如下:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                   <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))              </span><br><span class="line">                p = e;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有兴趣，大家可以去查询更过的相关资料</p><ul><li>扩容机制<br>  本人目前对JDK1.8 HashMap的扩容机制不是很了解，源码也还未读懂，等弄清楚了再来补上这部分的内容。</li></ul><p><strong>HashMap 的线程安全性</strong><br>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。</p><p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">HashMap 多线程操作导致死循环问题</a></p><p><strong>小结</strong></p><ul><li>1、扩容是一个特别耗性能的操作，所以在使用HashMap 时，估算map 的大小，初始化的时候给一个大致的数值，避免map 进行频繁的扩容。</li><li>2、负载因子是可以修改，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li><li>3、HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</li><li>4、JDK1.8引入红黑树大程度优化了HashMap的性能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HashMap 是 java 开发中使用频率最高的用于映射（键值对）处理的数据类型。随着JDK 版本的的更新，JDK1.8 对HashMap 底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。于是结合JDK1.7 和JDK1.8 两个目前主流的JDK版本的区别，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>由算法优化引发的思考---路漫漫而修远</title>
    <link href="http://wang818.top/2020/01/11/%E7%94%B1%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83---%E8%B7%AF%E6%BC%AB%E6%BC%AB%E8%80%8C%E4%BF%AE%E8%BF%9C/"/>
    <id>http://wang818.top/2020/01/11/%E7%94%B1%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83---%E8%B7%AF%E6%BC%AB%E6%BC%AB%E8%80%8C%E4%BF%AE%E8%BF%9C/</id>
    <published>2020-01-11T06:38:49.287Z</published>
    <updated>2020-01-11T06:38:12.999Z</updated>
    
    <content type="html"><![CDATA[<p> LeetCode 32 最长有效括号，这道题我很早就使用暴力破解的解法做过，但是超出时间限制。由于对动态规划算法有了进一步的认识，所以又重新以动态规划的思路来求解。但当我看到官方题解中其他的解法后，感觉自己的智商受到了碾压，官方题解的解法三和解法四（大家有兴趣可以去看一下）都给了我耳目一新的感觉。</p><p>一叶而可知秋，对于任何算法或者其他具体问题，都可以通过不断的改进而找到更好的解决方案。这道题让我想到了斐波那契数列的求解的不断优化，我最初的解法是直接使用递归求解，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line">        if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是直接使用递归求解，会重复计算一些子问题，例如，f(4)会计算f(3)和f(2)，而f(3)会计算f(2)和f(1),这样f(2)就被重复计算了一次</p><p>因此，可以使用动态规划将原问题的多个子问题的解存起来，这样就避免了重复计算，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int Fibonacci2(int n) &#123;</span><br><span class="line">        if(n &lt;&#x3D; 1) &#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp &#x3D; new int[n + 1];</span><br><span class="line">        dp[0] &#x3D; 1;</span><br><span class="line">        for(int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            dp[n] &#x3D; dp[n - 1] + dp[n - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>动态规划的时间复杂度很好，但是空间复杂度还是 O(n)，因此可以对空间复杂度进行优化，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int Fibonacci3(int n) &#123;</span><br><span class="line">        if(n &lt;&#x3D; 1) &#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int first &#x3D; 0;</span><br><span class="line">        int second &#x3D; 1;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            result +&#x3D; first + second;</span><br><span class="line">            first &#x3D; second;</span><br><span class="line">            second &#x3D; result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从这些算法题的不断优化的过程中，我体会到了什么叫没有最好，只有更好。希望自己以后可以像那些大牛一样，对任何问题都能做出最优的解答。<strong>路漫漫而修远啊！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; LeetCode 32 最长有效括号，这道题我很早就使用暴力破解的解法做过，但是超出时间限制。由于对动态规划算法有了进一步的认识，所以又重新以动态规划的思路来求解。但当我看到官方题解中其他的解法后，感觉自己的智商受到了碾压，官方题解的解法三和解法四（大家有兴趣可以去看一下
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL 索引原理及优化</title>
    <link href="http://wang818.top/2020/01/02/MySQL%20%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>http://wang818.top/2020/01/02/MySQL%20%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/</id>
    <published>2020-01-02T08:06:07.002Z</published>
    <updated>2020-01-02T08:05:44.014Z</updated>
    
    <content type="html"><![CDATA[<p>网上对于 MySQL 中的最重要知识点的说法一般有两种：</p><ul><li>索引、事务</li><li>索引、事务和查询</li></ul><p>我认为应该把查询加上，尤其是看到美团技术团队写的一篇关于<a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">MySQL  索引原理及慢查询优化后</a>，其中的查询主要是指查询优化以及编写高效率的 SQL 语句。</p><p>本文主要关注的是有关<strong>索引</strong>方面的，若未特别说明，以下内容默认是基于 <strong>MySQL Innodb</strong>存储引擎的 。</p><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>MySQL 官方对于索引的定义是：索引是<strong>存储引擎</strong>用于快速查找记录的一种<strong>数据结构</strong>。从官方的定义来看，索引是存储引擎层面的一种数据结构。    通俗来讲，索引就好比字典中的目录，如果我们要在字典中查找 MySQL，就先翻到以 M 开头的目录，然后再根据目录找出 MySQL 这个单词在多少页。</p><h2 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h2><p>在没有深入了解索引之前，我对索引的认识只限于：</p><ul><li><p>索引可以加快查询速度</p></li><li><p>索引分为聚簇索引和非聚簇索引</p><p>现在，我对索引有了更为深入的认识，也不仅仅是只知道索引的优点。我了解了<strong>索引到底有哪些优点</strong>、<strong>为什么索引有这些优点</strong>、<strong>索引有什么缺点</strong>、<strong>索引为什么有这些缺点</strong>。</p></li></ul><h3 id="索引的优点："><a href="#索引的优点：" class="headerlink" title="索引的优点："></a>索引的优点：</h3><p>参考《高性能MySQL》一书</p><ul><li>减少查询需要扫描的数据量（加快了查询速度）</li><li>减少服务器的排序操作和创建临时表的操作（加快了 group by 和 order by 等操作）</li><li>将服务器的随机 IO 变为 顺序 IO（加快查询速度）</li></ul><h3 id="索引的缺点："><a href="#索引的缺点：" class="headerlink" title="索引的缺点："></a>索引的缺点：</h3><ul><li><p>索引会降低插入、删除、修改等操作的速度（原因与下文的索引的数据结构有关）</p></li><li><p>索引需要占用物理和数据空间（很好理解，索引是一种数据结构，里面也存储了数据）</p><p>虽然索引也有其缺点，但是一般的系统<strong>读写比例大概是 10 : 1</strong>，因此。在一定数据范围内（索引不是特别多的情况下），建立索引的好处是远远大于索引的开销的，但是我们还是要避免索引的滥用，要知道索引建立及优化的相关知识。</p></li></ul><h2 id="有哪些类型的索引"><a href="#有哪些类型的索引" class="headerlink" title="有哪些类型的索引"></a>有哪些类型的索引</h2><h3 id="从数据结构的角度"><a href="#从数据结构的角度" class="headerlink" title="从数据结构的角度"></a>从数据结构的角度</h3><ul><li><p>B-树索引/B+树索引（可以参考<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 背后的数据结构及算法原理</a>）</p></li><li><p>哈希索引</p></li><li><p>全文索引</p></li><li><p>空间数据索引</p><h3 id="从物理存储的角度"><a href="#从物理存储的角度" class="headerlink" title="从物理存储的角度"></a>从物理存储的角度</h3></li><li><p>聚集索引（也称聚簇索引）</p></li><li><p>非聚集索引（也称非聚簇索引）</p><h3 id="从逻辑的角度"><a href="#从逻辑的角度" class="headerlink" title="从逻辑的角度"></a>从逻辑的角度</h3></li><li><p>主键索引（特殊的唯一索引，不允许有 null 值）</p></li><li><p>普通索引（单列索引）</p></li><li><p>复合索引（多列索引）</p></li><li><p>唯一索引或非唯一索引</p></li><li><p>空间索引</p></li></ul><h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p> MyISAM 存储引擎中索引和数据是分开的，索引文件仅仅保存的是数据记录的地址，因此属于非聚集索引（非聚簇索引）。</p><h4 id="主键索引（Primary-index）"><a href="#主键索引（Primary-index）" class="headerlink" title="主键索引（Primary index）"></a>主键索引（Primary index）</h4><p>  MyISAM 引擎使用 B+Tree作为索引结构，叶节点的 data 存放的是数据记录的地址。</p><h4 id="辅助索引（Secondary-Index）"><a href="#辅助索引（Secondary-Index）" class="headerlink" title="辅助索引（Secondary Index）"></a>辅助索引（Secondary Index）</h4><p>   MyISAM 中的辅助索引与主键索引没有什么太大的区别，只不过主键索引的 Key 是唯一的，而辅助索引的 Key 可以重复。</p><h3 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h3><h4 id="主键索引（Primary-index）-1"><a href="#主键索引（Primary-index）-1" class="headerlink" title="主键索引（Primary index）"></a>主键索引（Primary index）</h4><p>  Innodb 引擎的索引和数据在一个文件中，索引的叶节点保存了完整的数据记录和索引，因此属于聚集索引（聚簇索引）。</p><p>因为InnoDB的数据文件本身要按照主键聚集，所以InnoDB要求必须有主键。如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段rowid作为主键，这个字段长度为6个字节，类型为长整形。</p><p>由于 Innodb 索引 的实现特性，所以推荐使用自增主键，这也就是为什么在建表的时候习惯使用 Primary Key Auto_increment</p><p>使用自增主键有以下好处：</p><ul><li>自增key一般为int等整数型，key比较紧凑，这样m可以非常大，而且索引占用空间小。最极端的例子，如果使用50B的varchar（包括长度），那么m = 4 * 1024 / 54m = 75.85 ~= 76，深度最大log(76/2)(10^7) = 4.43 ~= 5，再加上cache缺失、字符串比较的成本，时间成本增加较大。同时，key由4B增长到50B，整棵索引树的空间占用增长也是极为恐怖的（如果二级索引使用主键定位数据行，则空间增长更加严重）</li><li>MySQL索引底层的数据比较都是整数型比较，如果主键时字符串类型的，里面还有英文，还得转换ASCII码进行比较。所以不建议使用uuid作为主键</li><li>自增的主键使得数据行的插入比如落到索引数的最右侧，发生节点分裂的频率较低。B+Tree实际操作插入过程。如果不是非单调主键，插入过程很大程度会发生节点重排，不利于索引优化的初衷</li></ul><h2 id="创建高性能的索引"><a href="#创建高性能的索引" class="headerlink" title="创建高性能的索引"></a>创建高性能的索引</h2><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p> 在对一个比较长的字符串进行索引时，可以仅索引字符串开始的一部分字符。这样可以大大节约索引空间，从而提高索引效率，但是这样也会降低索引的选择性（降低查询的准确度）。</p><p>索引的选择性: 不重复的值/所有的值. 可以看出索引的选择性为 0-1 ,最高的就是该列唯一,没有重复值</p><p>通过下述 SQL 语句可以计算出长字符串的选择性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">    count(distinct left(long_String,3))&#x2F;count(*) as s3, </span><br><span class="line">    count(distinct left(long_String,4))&#x2F;count(*) as s4,</span><br><span class="line">    count(distinct left(long_String,5))&#x2F;count(*) as s5,</span><br><span class="line">    count(distinct long_String)&#x2F;count(*) as original</span><br><span class="line">from </span><br><span class="line">    user;</span><br></pre></td></tr></table></figure><p>其中查找到的 original 就是原本的选择性, s3 , s4 ,s5 分别是取该列的前3,4,5个字符作为索引的时候的选择性.逐步增加这个数值,当选择性与原来相差不大的时候,就是一个比较合适的前缀索引的长度</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p> 一般我们都是有对多个列进行索引的需求的,因为查询的需求多种多样。这个时候我们可以选择建立多个独立的索引或者建立一个联合索引.大多数时候都是联合索引更加合适一些</p><p>从理论上来讲,MySQL在5.0之后的版本里面对支持合并索引,也就是同时使用两个索引,但是MySQL的优化器不一定这样认为，他可能会认为，查询两次B+树的代价高于查询一次索引之后去数据表进行过滤,因此会选择只用一个索引</p><p>使用联合索引的时候,有一个非常重要的因素就是所有的索引列只可以进行最左前缀匹配。在不考虑任何的情况下，应该将选择性高的列放在联合索引的前面</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p> 当一个索引包含(或者说是覆盖)需要查询的所有字段的值时,我们称之为覆盖索引。<br> 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name, age from user where name&#x3D;&quot;王&quot;;</span><br></pre></td></tr></table></figure><p>Innodb 存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，不需要查询聚簇索引中的记录了。可以减少大量的IO操作。</p><p>如果要查询辅助索引中不含有的字段，得先遍历辅助索引，再遍历聚集索引，而如果要查询的字段值在辅助索引上就有，就不用再查聚集索引了，这显然会减少IO操作。</p><h2 id="建立索引的几大原则"><a href="#建立索引的几大原则" class="headerlink" title="建立索引的几大原则"></a>建立索引的几大原则</h2><ul><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整</li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li><li>尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0</li><li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2020-02-01’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2020-02-01’)</li><li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>《高性能MySQL》</p><p><a href="https://juejin.im/post/5b55b842f265da0f9e589e79#heading-7" target="_blank" rel="noopener">数据库两大神器</a></p><p><a href="https://juejin.im/post/5d4d82caf265da039c6360ff#heading-11" target="_blank" rel="noopener">详解 MySQL 索引原理及其优化</a></p><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">MySQL  索引原理及慢查询优化</a></p><p><a href="https://juejin.im/post/5d63348ae51d453b1e478ae3#heading-8" target="_blank" rel="noopener">性能调优-MySQL  索引数据结构详解与索引优化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网上对于 MySQL 中的最重要知识点的说法一般有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引、事务&lt;/li&gt;
&lt;li&gt;索引、事务和查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我认为应该把查询加上，尤其是看到美团技术团队写的一篇关于&lt;a href=&quot;https://tech.meituan
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从 LeetCode_28_strStr() 到 KMP 算法</title>
    <link href="http://wang818.top/2020/01/02/%E4%BB%8E%20LeetCode_28_strStr()%20%E5%88%B0%20KMP%20%E7%AE%97%E6%B3%95/"/>
    <id>http://wang818.top/2020/01/02/%E4%BB%8E%20LeetCode_28_strStr()%20%E5%88%B0%20KMP%20%E7%AE%97%E6%B3%95/</id>
    <published>2020-01-02T04:10:57.590Z</published>
    <updated>2020-01-02T04:10:19.145Z</updated>
    
    <content type="html"><![CDATA[<p>这些天一直在回顾 LeetCode 上刷过的题，当看到第 28 题实现 strStr() 时，我发现虽然它是简单题，可以使用 Java 的 indesOf() 和暴力遍历轻松的解答，但是更好也更为符合实际的应该是用 <strong>KMP 算法</strong>。关于什么是 KMP 算法，大家可以自己去 google，或者参考<strong>严蔚敏</strong>老师的《数据结构》。</p><p>这里我要分享的只是简单的实现以及其它大佬的解题思路（因为我现在对 KMP 算法理解的也不够深入）。</p><p>KMP 算法的大体思路可以参考<a href="https://www.bilibili.com/video/av11866460?from=search&seid=10982649512556638720" target="_blank" rel="noopener">KMP 字符串匹配算法</a></p><p>个人认为视频讲解比画图讲解会好一点，毕竟视频是动态的。</p><p>KMP 算法中的重难点是 next 数组的生成以及具体实现中模式串匹配。具体可以参考一下文章。珠玉在前，我就不分享自己还不够清晰完整的思路了。等我有了更为深入的理解后会来补充这一部分。</p><ul><li><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">从头到尾理解 KMP</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/40402710" target="_blank" rel="noopener">深入了解 KMP 算法中的 next 数组</a></p><p>以下是我关于 LeetCode 上的第 28 道题来具体实现 KMP 算法代码</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        if(needle &#x3D;&#x3D; null || needle.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] next &#x3D; new int[needle.length()];</span><br><span class="line">        &#x2F;&#x2F; 得到 next 数组</span><br><span class="line">        getNextArr(next, needle);</span><br><span class="line">        &#x2F;&#x2F; 使用双指针进行匹配</span><br><span class="line">        int i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">        while(i &lt; haystack.length() &amp;&amp; j &lt; needle.length()) &#123;</span><br><span class="line">            if(j &#x3D;&#x3D; -1 || haystack.charAt(i) &#x3D;&#x3D; needle.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                j &#x3D; next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return j &#x3D;&#x3D; needle.length() ? i - j : -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void getNextArr(int[] next, String needle) &#123;</span><br><span class="line">        int k &#x3D; -1;</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        next[0] &#x3D; -1;</span><br><span class="line">        while(j &lt; needle.length() - 1) &#123;</span><br><span class="line">            if(k &#x3D;&#x3D; -1 || needle.charAt(j) &#x3D;&#x3D; needle.charAt(k)) &#123;</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">                next[j] &#x3D; k;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                k &#x3D; next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这些天一直在回顾 LeetCode 上刷过的题，当看到第 28 题实现 strStr() 时，我发现虽然它是简单题，可以使用 Java 的 indesOf() 和暴力遍历轻松的解答，但是更好也更为符合实际的应该是用 &lt;strong&gt;KMP 算法&lt;/strong&gt;。关于什么是
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Stack Overflow Developer Survey 2019</title>
    <link href="http://wang818.top/2020/01/01/Stack%20Overflow%20Developer%20Survey%202019/"/>
    <id>http://wang818.top/2020/01/01/Stack%20Overflow%20Developer%20Survey%202019/</id>
    <published>2020-01-01T12:51:00.962Z</published>
    <updated>2020-01-01T12:50:38.378Z</updated>
    
    <content type="html"><![CDATA[<p>今天是 2020 年的第一天，回顾过去的 2019 年，似乎也并没有发生什么特别的事情。所以只好和大家分享一下 Stack Overflow 的 2019 年度开发人员调查了（看一下别人的年度总结）。</p><p><a href="https://insights.stackoverflow.com/survey/2019" target="_blank" rel="noopener">Stack Overflow Developer Survey 2019</a><br>这个调查报告有90000名程序员参与，这份调度报告平均花了20分钟，可见，这份报告问了很多的问题，也是很详细的。</p><p><strong>报告中的 key Results 是</strong></p><ul><li>Python是增长最快的主要编程语言，在 Stack Overflow 的调查中，它再次在编程语言中排名上升，今年排在Java之后，成为第二大最受欢迎的语言（仅次于Rust）。</li><li>超过一半的受访者在16岁时就已经编写了第一行代码，尽管这种经历因国家和性别而异。</li><li>DevOps Specialists 和 Site Reliability Engineers （相当于国内的系统架构师）是薪水最高，经验最丰富的开发人员。</li><li>在调查的前几个国家中，中国的开发者最乐观，他们认为今天出生的人的生活会比父母更好。西欧国家（例如法国和德国）的卡发着对未来的乐观程度最低。</li><li>对于最影响程序员生产力的事情，不同测程序员有不同的看法。</li></ul><h2 id="开发人员类型"><a href="#开发人员类型" class="headerlink" title="开发人员类型"></a>开发人员类型</h2><p><img src="https://img-blog.csdnimg.cn/20200101200821754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="开发人员类型"><br>由上图可知：</p><ul><li><p>对于技术职业来说，整个世界的程序员开始趋于全栈和后端，有51.9%的人是全栈，50%的人是后端，32.8%的人是前端……在这些人中，很多程序员都选了多项，中位数是3项，最常见是前端、后端和全栈全选的。然后，接下来是选两项的，选两项目的包括：数据库管理员和系统管理员，DevOps Specialist 和 Site Reliablility Engineer， 学术研究者和科学家，设计师和前端工程师。</p></li><li><p>前后端的界限越来越不明显，设计师和前端的界限也开始模糊。这应该说明，工具和框架的成熟，让后端程序员和设计师也可以进入到前端工程师的领域，或是前端工程师开始进入后端和设计的领域。总之，复合型人才越来越越成为主流，而前后端也趋于一个相互融合的态势。</p><p>在调查程序开发人员把编程当做爱好还是只是谋生的手段后，得出了一下结论<br><img src="https://img-blog.csdnimg.cn/2020010120130967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="Coding as a Hobby"><br>从上表可知，绝大多数人还是热爱编程的。确实，热爱在某种程度上可以看做是一种信仰，只有对自己从事的工作充满热爱，才能投入更多的时间和精力，从而成为专业领域内的领先者。</p></li></ul><h2 id="学习编程的年限和从事编程行业的年限以及编写第一行代码的年限"><a href="#学习编程的年限和从事编程行业的年限以及编写第一行代码的年限" class="headerlink" title="学习编程的年限和从事编程行业的年限以及编写第一行代码的年限"></a>学习编程的年限和从事编程行业的年限以及编写第一行代码的年限</h2><p><img src="https://img-blog.csdnimg.cn/20200101201755552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="学习编程的年限"><br><img src="https://img-blog.csdnimg.cn/20200101201911886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="从事编程行业的年限"><br><img src="https://img-blog.csdnimg.cn/20200101202149782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="编写第一行代码的年限"><br>从上图确实是可以看出来互联网一行是吃青春饭的说法并不是空穴来风的（当然，也不是绝对），能够坚持很长时间的程序员只是少数，这也挺正常的，对很大一部分人来说，对这个职业是有或多或少的不满意的，也有一部分人可能会随着技术的更新被淘汰，还有另外很大一部分人是想转管理的。</p><p>从我个人的角度来说，我是愿意坚持做技术的。希望我的这种初心不会随着走出校园、走入社会而渐渐遗失。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>最流行的语言<br><img src="https://img-blog.csdnimg.cn/2020010120302753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="最流行的语言"><br>最热门的语言<br><img src="https://img-blog.csdnimg.cn/20200101203150229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="最热门的语言"><br>Stack Overflow 官方发布的调查报告报告中还包含各种编程语言的薪资图、最常用的 Web 框架、最常用的其它开发框架/库/工具、最受欢迎的操作系统、最常用的数据库以及最常用的开发工具等，如果有兴趣，可以去官方报告查看。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p><img src="https://img-blog.csdnimg.cn/20200101203855815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="工作方式"><br>从上图可知，绝大多数开发人员是全职的。</p><p><img src="https://img-blog.csdnimg.cn/20200101204101674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="公司规模"><br>从上图可知，在中小型公司工作的程序员占多数，这也很好理解。</p><p><img src="https://img-blog.csdnimg.cn/20200101204212567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="Career Values"><br>从上图可知，大部分的程序员还是比较满意自己的工作的。</p><p>不同技术类型程序员的薪水<br><img src="https://img-blog.csdnimg.cn/20200101204428912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="salary"><br>从上图可知，我们从事后端开发的薪水还是可以的。</p><p><img src="https://img-blog.csdnimg.cn/20200101204637685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="Working Hours"><br>每周工作多少个小时，因为参与调查的开发者大多是外国人，参考价值不是很大，了解一下就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是 2020 年的第一天，回顾过去的 2019 年，似乎也并没有发生什么特别的事情。所以只好和大家分享一下 Stack Overflow 的 2019 年度开发人员调查了（看一下别人的年度总结）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.sta
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java主流锁之悲观锁和乐观锁的简单模拟实现</title>
    <link href="http://wang818.top/2019/12/29/java%E4%B8%BB%E6%B5%81%E9%94%81%E4%B9%8B%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wang818.top/2019/12/29/java%E4%B8%BB%E6%B5%81%E9%94%81%E4%B9%8B%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-12-29T07:51:03.571Z</published>
    <updated>2019-12-29T07:50:14.733Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章<a href="https://blog.csdn.net/wangbo818/article/details/103747333" target="_blank" rel="noopener">java主流锁之悲观锁和乐观锁</a>中，我们已经知道了什么是乐观锁和悲观锁以及他们的实现方式和使用场景。</p><p>现在就来简单模拟实现悲观锁和乐观锁</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p><strong>首先在数据库中创建一张goods 表</strong><br><img src="https://img-blog.csdnimg.cn/20191228224524227.png" alt="创建goods表"><br><strong>向数据库中插入一条记录</strong><br><img src="https://img-blog.csdnimg.cn/20191228224657968.png" alt="插入数据"><br><strong>如果要进行减少count 操作的话，则首先查询出count 数量，若count 数量大于0，则可以进行修改操作。悲观锁是在查询的时候就将该条记录锁定</strong><br><img src="https://img-blog.csdnimg.cn/20191229152215694.png" alt="开启事务"><br><strong>此时其他的客户端只能进行查询操作，而无法进行其他任何操作</strong><br><img src="https://img-blog.csdnimg.cn/20191229152309174.png" alt="阻塞"><br><strong>只有等拿到锁的客户端提交事务，另一个客户端才可以再对其进行修改等操作</strong><br><img src="https://img-blog.csdnimg.cn/20191229152431998.png" alt="commit"><br><img src="https://img-blog.csdnimg.cn/20191229152505737.png" alt="修改成功"></p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><strong>首先在数据库中创建goods 表，但是与悲观锁不同的是在创建表的时候添加一个version 字段</strong><br><img src="https://img-blog.csdnimg.cn/2019122823063249.png" alt="创建goods表"><br><strong>向goods 表中插入一条记录</strong><br><img src="https://img-blog.csdnimg.cn/20191228231525447.png" alt="添加记录"><br><strong>此时如果要减少count 的话，则首先查询出count 数量，若count 数量大于0，则可以进行修改操作</strong><br><img src="https://img-blog.csdnimg.cn/20191228231839465.png" alt="查询库存"><br><img src="https://img-blog.csdnimg.cn/2019122823305733.png" alt="修改"><br><strong>此时另外开启一个MySQL 客户端，进行同样的修改操作，因为版本号不一致，所以修改失败</strong><br><img src="https://img-blog.csdnimg.cn/20191228233204609.png" alt="修改失败"><br><strong>此时用正确的版本号去修改，可以看到修改成功</strong><br><img src="https://img-blog.csdnimg.cn/20191228233344744.png" alt="修改成功"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇文章&lt;a href=&quot;https://blog.csdn.net/wangbo818/article/details/103747333&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java主流锁之悲观锁和乐观锁&lt;/a&gt;中，我们已经知道了什么是乐
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java主流锁之乐观锁和悲观锁</title>
    <link href="http://wang818.top/2019/12/28/java%E4%B8%BB%E6%B5%81%E9%94%81%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://wang818.top/2019/12/28/java%E4%B8%BB%E6%B5%81%E9%94%81%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</id>
    <published>2019-12-28T12:23:22.805Z</published>
    <updated>2019-12-28T12:22:53.488Z</updated>
    
    <content type="html"><![CDATA[<p>java提供了很多种类的锁，每种锁都有其特性，根据特性在适当的场景下能够展现出非常高的效率。</p><p>下图来源于<a href="https://zhuanlan.zhihu.com/p/50098743" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50098743</a><br><img src="https://img-blog.csdnimg.cn/20191228183759965.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="java主流锁"><br>在一个高并发秒杀的场景下中，很有可能会出现超卖的情况，要解决超卖的问题，可以对数据库中的表或记录加锁。我刚开始在秒杀项目中是用悲观锁来解决超卖的问题，但是在并发量很高的情况，悲观锁的效率可能不是很好，因此，我改用乐观锁来代替悲观锁。那么，什么是乐观锁和悲观锁呢？乐观锁在并发量很高的情况下性能为什么要优于悲观锁呢？怎样简单实现乐观锁和悲观锁呢（下一篇文章中实现）？</p><h2 id="什么是悲观锁和乐观锁？"><a href="#什么是悲观锁和乐观锁？" class="headerlink" title="什么是悲观锁和乐观锁？"></a>什么是悲观锁和乐观锁？</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>正如其名，它指的是对数据被外界（包括本系统的其它事务，以及来自外部系统的事务处理）修改持保守态度，因此，每次对数据进行操作时，都会将数据置为被锁定状态，这样别的事务想要拿到这个数据都会阻塞。悲观的实现，往往依靠数据库提供的锁机制（也只有数据库提供的锁机制才能真正保证数据访问的排他性）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其他事务只能读数据，而不能修改、删除数据。当修改删除数据时也要加锁，此时其他事务无法读取数据。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>相对悲观锁而言，乐观锁采取了更为宽松的锁机制。悲观锁大部分情况下都要依靠数据库的锁机制实现，以保证操作的独占性。但是随之而来的就是数据库性能的大幅度开销，特别是对长事务来说，这样的开销往往无法接受。</p><p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，顾名思义，总是假设最好的情况，每次去拿数据的时候都认为只有自己一个人拿，因此就不会加锁，但是在更新的时候会判断在自己操作数据期间，有没有其他人操作过数据。</p><p>乐观锁，大多是基于数据版本（Version）记录机制实现的。那什么是数据版本？数据版本就是为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过给数据库表增加一个”Version” 字段来实现。读取数据时，将此版本号一起读出，之后更新时，将此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p>除了使用版本号机制外，还可以使用CAS算法来实现乐观锁。例如：在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的CAS实现方式实现的。</p><h3 id="乐观锁和悲观锁的使用场景"><a href="#乐观锁和悲观锁的使用场景" class="headerlink" title="乐观锁和悲观锁的使用场景"></a>乐观锁和悲观锁的使用场景</h3><p>从以上对两种锁的介绍可以知道两种锁各有其有优缺点，不能认为一种好于另一种，只是说适用于不同的场景。像乐观锁适用于写比较少的场景（多读场景），即冲突真的很少发生的时候，这样就省去了锁的开销，加到了系统的整个吞吐量。但如果是多写的情况，一般会经常发生冲突，这会导致上层的应用会不断地进行retry，这样反倒是降低了性能。所以一般多写的场景下使用悲观锁。</p><h3 id="乐观锁实现方式"><a href="#乐观锁实现方式" class="headerlink" title="乐观锁实现方式"></a>乐观锁实现方式</h3><p>出来上述的基于版本号机制实现乐观锁外，最长是采用CAS（Compare And Swap（比较与交换））算法实现。CAS算法是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）</p><p>CAS算法基于三个操作数：</p><ul><li><p>需要读写的内存值V</p></li><li><p>进行比较的值A</p></li><li><p>拟写入的新值B</p><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p></li></ul><p>当然，虽然CAS算法很高效，但是也会存在很多问题，例如：</p><ul><li>ABA问题</li><li>循环时间长开销大</li><li>只能保证一个共享变量的原子操作</li></ul><p>我对这些问题产生的原因和解决方案也了解的不是很清楚，所以如果大家有兴趣的话，可以去查阅相关资料。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java提供了很多种类的锁，每种锁都有其特性，根据特性在适当的场景下能够展现出非常高的效率。&lt;/p&gt;
&lt;p&gt;下图来源于&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50098743&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PAT乙级真题题解java实现</title>
    <link href="http://wang818.top/2019/12/28/PAT%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98%E9%A2%98%E8%A7%A3java%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wang818.top/2019/12/28/PAT%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98%E9%A2%98%E8%A7%A3java%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-12-28T09:21:03.712Z</published>
    <updated>2019-12-28T09:17:55.020Z</updated>
    
    <content type="html"><![CDATA[<p>虽然这次PAT考试的成绩并不算理想，但还是有了很多收获，特别是认识了一些很优秀的人以及他们平时怎么学习算法。</p><p>我参加的2019年冬季PAT乙级考试，这个时间PAT官网上的乙级真题有95道，我是使用java来做的（推荐使用c语言）。大部分题都是通过的，部分题目超出时间限制，<br>还有一部分只通过了部分用例。</p><p>以下是题目清单及我的通过情况：<br><a href="https://github.com/WangBo0818/PAT" target="_blank" rel="noopener">GitHub仓库</a></p><ul><li><p>完全正确</p><ul><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1001.java" target="_blank" rel="noopener">1001 害死人不偿命的(3n+1)猜想</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1002.java" target="_blank" rel="noopener">1002 写出这个数</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1003.java" target="_blank" rel="noopener">1003 我要通过！</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1004.java" target="_blank" rel="noopener">1004 成绩排名</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1005.java" target="_blank" rel="noopener">1005 继续(3n+1)猜想</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1006.java" target="_blank" rel="noopener">1006 换个格式输出整数</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1007.java" target="_blank" rel="noopener">1007 素数对猜想</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1008.java" target="_blank" rel="noopener">1008 数组元素循环右移问题</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1009.java" target="_blank" rel="noopener">说反话</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1010.java" target="_blank" rel="noopener">1010 一元多项式求导</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1011.java" target="_blank" rel="noopener">1011 A+B 和 C</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1012.java" target="_blank" rel="noopener">1012 数字分类</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1013.java" target="_blank" rel="noopener">1013 数素数</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1016.java" target="_blank" rel="noopener">1016 部分A+B</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1017.java" target="_blank" rel="noopener">1017 A除以B</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1019.java" target="_blank" rel="noopener">1019 数字黑洞</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1020.java" target="_blank" rel="noopener">1020 月饼</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1021.java" target="_blank" rel="noopener">1021 个位数统计</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1022.java" target="_blank" rel="noopener">1022 D进制的A+B</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1023.java" target="_blank" rel="noopener">1023 组个最小数</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1024.java" target="_blank" rel="noopener">1024 科学计数法</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1026.java" target="_blank" rel="noopener">1026     程序运行时间</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1027.java" target="_blank" rel="noopener">1027 打印沙漏</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1029.java" target="_blank" rel="noopener">1029 旧键盘</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1036.java" target="_blank" rel="noopener">1036 跟奥巴马一起编程</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1037.java" target="_blank" rel="noopener">1037     在霍格沃茨找零钱</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1039.java" target="_blank" rel="noopener">1039 到底买不买</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1040.java" target="_blank" rel="noopener">1040 有几个PAT</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1041.java" target="_blank" rel="noopener">1041 考试座位号</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1042.java" target="_blank" rel="noopener">1042 字符统计</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1043.java" target="_blank" rel="noopener">1043 输出PATest</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1044.java" target="_blank" rel="noopener">1044 火星数字</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1046.java" target="_blank" rel="noopener">1046 划拳</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1047.java" target="_blank" rel="noopener">1047 编程团体赛</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1051.java" target="_blank" rel="noopener">1051 复数乘法</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1053.java" target="_blank" rel="noopener">1053 住房空置率</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1054.java" target="_blank" rel="noopener">1054 求平均值</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1055.java" target="_blank" rel="noopener">1055 集体照</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1056.java" target="_blank" rel="noopener">1056 组合数的和</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1057.java" target="_blank" rel="noopener">1057 数零壹</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1061.java" target="_blank" rel="noopener">1061 判断题</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1064.java" target="_blank" rel="noopener">1064 朋友数</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1067.java" target="_blank" rel="noopener">1067 试密码</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1069.java" target="_blank" rel="noopener">1069 微博转发抽奖</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1070.java" target="_blank" rel="noopener">1070 结绳</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1076.java" target="_blank" rel="noopener">1076 Wifi密码</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1077.java" target="_blank" rel="noopener">1077 互评成绩计算</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1078.java" target="_blank" rel="noopener">1078 字符串压缩与解压</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1081.java" target="_blank" rel="noopener">1081 检查密码</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1083.java" target="_blank" rel="noopener">1083 是否存在相等的差</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1084.java" target="_blank" rel="noopener">1084 外观数列</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1086.java" target="_blank" rel="noopener">1086 就不告诉你</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1087.java" target="_blank" rel="noopener">1087 有多少不同的值</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1088.java" target="_blank" rel="noopener">1088 三人行</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1089.java" target="_blank" rel="noopener">1089 狼人杀-简单版</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1090.java" target="_blank" rel="noopener">1090 危险品装箱</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1091.java" target="_blank" rel="noopener">1091 N-自守数</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1093.java" target="_blank" rel="noopener">1093 字符串A+B</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1094.java" target="_blank" rel="noopener">1094 谷歌的招聘</a></li></ul></li><li><p>超出时间限制</p><ul><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1015.java" target="_blank" rel="noopener">1015 德才论</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1018.java" target="_blank" rel="noopener">1018 锤子剪刀布</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1025.java" target="_blank" rel="noopener">1025 反转链表</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1030.java" target="_blank" rel="noopener">1030 完美数列</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1032.java" target="_blank" rel="noopener">1032 挖掘机技术哪家强</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1038.java" target="_blank" rel="noopener">1038 统计同成绩学生</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1045.java" target="_blank" rel="noopener">1045 快速排序</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1049.java" target="_blank" rel="noopener">1049 数列的片段和</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1050.java" target="_blank" rel="noopener">1050 螺旋矩阵</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1058.java" target="_blank" rel="noopener">1058 选择题</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1060.java" target="_blank" rel="noopener">1060 爱丁顿数</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1062.java" target="_blank" rel="noopener">1062 最简分数</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1063.java" target="_blank" rel="noopener">1063 计算谱半径</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1065.java" target="_blank" rel="noopener">1065 单身狗</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1066.java" target="_blank" rel="noopener">1066 图像过滤</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1073.java" target="_blank" rel="noopener">1073 多选题常见计分法</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1079.java" target="_blank" rel="noopener">1079 延迟的回文数</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1080.java" target="_blank" rel="noopener">1080 MOOC期终成绩</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1082.java" target="_blank" rel="noopener">1082 射击比赛</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1085.java" target="_blank" rel="noopener">1085 PAT单位排行</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1092.java" target="_blank" rel="noopener">1092 最好吃的月饼</a></li><li></li></ul></li><li><p>部分通过</p><ul><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1014.java" target="_blank" rel="noopener">1014 福尔摩斯的约会</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1028.java" target="_blank" rel="noopener">1028 人口普查</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1031.java" target="_blank" rel="noopener">1031 查验身份证</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1033.java" target="_blank" rel="noopener">1033 旧键盘打字</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1034.java" target="_blank" rel="noopener">1034 有理数四则运算</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1035.java" target="_blank" rel="noopener">1035 插入与归并</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1048.java" target="_blank" rel="noopener">1048 数字加密</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1059.java" target="_blank" rel="noopener">1059 C语言竞赛</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1068.java" target="_blank" rel="noopener">1068 万绿丛中一点红</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1071.java" target="_blank" rel="noopener">1071 小赌怡情</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1072.java" target="_blank" rel="noopener">1072 开学寄语</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1074.java" target="_blank" rel="noopener">1074 宇宙无敌加法器</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1075.java" target="_blank" rel="noopener">1075 链表元素分类</a></li><li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1095.java" target="_blank" rel="noopener">1095 解码PAT准考证</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然这次PAT考试的成绩并不算理想，但还是有了很多收获，特别是认识了一些很优秀的人以及他们平时怎么学习算法。&lt;/p&gt;
&lt;p&gt;我参加的2019年冬季PAT乙级考试，这个时间PAT官网上的乙级真题有95道，我是使用java来做的（推荐使用c语言）。大部分题都是通过的，部分题目超
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>阿里巴巴Java 约规手册：码出高效，码出质量</title>
    <link href="http://wang818.top/2019/12/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%20%E7%BA%A6%E8%A7%84%E6%89%8B%E5%86%8C%EF%BC%9A%E7%A0%81%E5%87%BA%E9%AB%98%E6%95%88%EF%BC%8C%E7%A0%81%E5%87%BA%E8%B4%A8%E9%87%8F/"/>
    <id>http://wang818.top/2019/12/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%20%E7%BA%A6%E8%A7%84%E6%89%8B%E5%86%8C%EF%BC%9A%E7%A0%81%E5%87%BA%E9%AB%98%E6%95%88%EF%BC%8C%E7%A0%81%E5%87%BA%E8%B4%A8%E9%87%8F/</id>
    <published>2019-12-25T15:06:35.000Z</published>
    <updated>2019-12-25T15:23:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>最近在和实验室的同学一起给学校教务处做一个教学工作量统计系统，在团队一起合作开发及测试的过程中，我认识到了自己在开发规范方面的不足，虽然以前就看过<strong>阿里巴巴Java 约规手册</strong>，但是我在平时自己做项目、学习的过程中并没有很注意，只遵守驼峰命名等较为基础的约规。在这次的开发过程中，因为开发当中的不规范而导致了很多问题，例如：</p><ul><li>POJO 类及方法返回值的类型都定义的是 int 等基本类型，而不是 Integer 等引用类型，这样在数据库里的数据为空的情况下或者页面传来null 值的时候，系统就会报错；</li><li>在工作量计算时，所需的常量也未使用枚举或类静态常量定义，从而导致程序里有许多魔数，这也会使维护变得困难；</li><li>大家都是第一次实际自己设计并实现一个系统，在构想的时候难免不充分，在全局异常处理以及全局返回值定义方面没有统一，这将导致一旦系统出现异常无法做出足够正确的处理</li><li>数据库的表结构和索引具有一定的缺陷，这可能会导致系统的架构缺陷和性能风险</li></ul><p>所以我重新看了阿里巴巴Java 约规手册，在经过这次实战后，我对开发规范的重视程度提高了很多，对为什么要严格遵守约规有了更深入的认识，可能软件工程师与码农的区别不仅仅是技术、架构上差别，还有写出的代码的质量。</p><p>以下是约规手册的部分内容概述：</p><ul><li>代码中的命名均不能以下划线或美元符号开始，也不能以其结束</li><li>代码中的命名严禁中英文混合，更不允许使用中文，应使用正确的英文拼写和语法‘’</li><li>类名要使用 UpperCamelCase 风格，除了DO / BO / DTO / VO / AO / PO 等领域模型</li><li>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从<br>驼峰形式</li><li>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚</li><li>抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类<br>命名以它要测试的类名开始，以 Test 结尾</li><li>类型与中括号紧挨相连来定义数组。例如：String[] args 而不是 String args[]</li><li>POJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误</li><li>包名统一使用小写，点分隔符之间仅有一个自然语义的英文单词</li><li>杜绝绝大部分缩写（个人认为杜绝所有缩写）</li><li>命名变量、常量等要做到看文知义</li><li>如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式</li><li>接口类中的方法和属性不要加任何修饰符号尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量</li><li>枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开</li><li>Service/DAO 层方法命名规约：获取单个对象的方法用 get 作前缀、获取多个对象的方法用 list 作前缀、获取统计值的方法用 count 作前缀、插入的方法用 save/insert 作前缀、删除的方法用 remove/delete 作前缀、修改的方法用 update 作前缀</li><li>领域模型命名规约：数据对象：xxxDO，xxx 即为数据表名；数据传输对象：xxxDTO，xxx 为业务领域相关的名称；展示对象：xxxVO，xxx 一般为网页名称；POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO</li><li>不允许任何魔数出现在代码中（深有体会）</li><li>long 或 Long 赋初始值时，使用大写的 L，以免与1混淆</li><li>不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护</li><li>注意常量的复用层次，根据不同的复用层次来决定常量放置的位置</li><li>如果变量值仅在一个固定范围内变化用 enum 类型来定义（例如一年有几个季节）</li><li>if/for/while/switch/do 等保留字与括号之间都必须加空格</li><li>任何二目、三目运算符的左右两边都需要加一个空格</li><li>采用 4 个空格缩进，禁止使用 tab 字符</li><li>注释的双斜线与注释内容之间有且仅有一个空格</li><li>IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，<br>不要使用 Windows 格式</li><li>避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成<br>本，直接用类名来访问即可</li><li>所有的覆写方法，必须加@Override 注解</li><li>避免使用可变参数编程</li><li>不能使用过时的类或方法</li><li>Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用<br>equals（例如：”hello”.equals(object) 而不是 object.equals(“hello”)）</li><li>所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较</li><li><strong>所有的 POJO 类属性必须使用包装数据类型</strong></li><li><strong>RPC 方法的返回值和参数必须使用包装数据类型</strong></li><li>所有的局部变量使用基本数据类型</li><li>定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值</li><li>在进行序列化和反序列化时不要轻易修改serialVersionUID 的值</li><li>POJO 类必须写 toString 方法。使用 IDE 中的工具：source&gt; generate toString<br>时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString</li><li>使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无<br>内容的检查，否则会有抛 IndexOutOfBoundsException 的风险</li><li>setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在<br>getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度</li><li>循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展（有利于提高效率）</li><li>慎用 Object 的 clone 方法来拷贝对象</li><li>类成员与方法访问控制从严</li><li>要注意对 ArrayList 的 subList 的操作，以及 subList 不可强转成 ArrayList</li><li>不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator<br>方式，如果并发操作，需要对 Iterator 对象加锁</li><li>使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历</li><li>获取单例对象需要保证线程安全，其中的方法也要保证线程安全</li><li>创建线程或线程池时请指定有意义的线程名称，方便出错时回溯</li><li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</li><li>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能<br>锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁</li><li>ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static<br>修饰</li><li>在 if/else/for/while/do 语句中必须使用大括号</li><li>在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程<br>序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使空代码 </li><li>在高并发场景中，避免使用”等于”判断作为中断或退出的条件（因为等值判断可能被击穿）</li><li>避免采用取反逻辑运算符</li><li>要注意参数校验的场景（内部校验和外部校验）</li><li>类、类属性、类方法的注释必须使用 Javadoc 规范，使用/<em>*内容</em>/格式，不得使用// xxx 方式</li><li>所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、<br>异常说明外，还必须指出该方法做什么事情，实现什么功能</li><li>所有的类都必须添加创建者和创建日期</li><li>所有的枚举类型字段必须要有注释，说明每个数据项的用途</li><li>代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑<br>等的修改</li><li>待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）</li><li>错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）</li><li>Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过<br>catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等</li><li>异常不要用来做流程控制，条件控制</li><li>catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。<br>对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理</li><li>异常捕获后必须要进行处理</li><li>有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回<br>滚事务</li><li>finally 块必须对资源对象、流对象进行关闭</li><li>捕获异常与抛异常，必须是完全匹配</li><li>防止 NullPointerException 是程序员的基本修养，要注意 NullPointerException 发生的场景</li><li>避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则</li><li>应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架<br>SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一</li><li>日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点</li><li>注意日志文件的命名方式</li><li>对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方<br>式，以免造成资源的浪费</li><li>后台输送给页面的变量必须加$!{var}——中间的感叹号</li><li>注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够<br>取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法</li><li>获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime()</li><li>不要在视图模板中加入任何复杂的逻辑</li><li>任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存</li><li>隶属于用户个人的页面或者功能必须进行权限控制校验</li><li>用户敏感数据禁止直接展示，必须对展示数据进行脱敏</li><li>严禁SQL 注入</li><li>用户请求传入的任何参数必须做有效性验证</li><li>表单、AJAX 提交必须执行 CSRF 安全过滤</li><li>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint<br>（ 1 表示是，0 表示否）</li><li>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只<br>出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑</li><li>表名不使用复数名词</li><li>禁用MYSQL官方保留字</li><li>小数类型为 decimal，禁止使用 float 和 double</li><li>表必备三字段：id, gmt_create, gmt_modified</li><li>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表</li><li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引</li><li>超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，<br>保证被关联的字段需要有索引</li><li>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决</li><li>利用延迟关联或者子查询优化超多分页场景</li><li>不要使用 count(列名)或 count(常量)来替代 count(*)</li><li>当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为<br>NULL，因此使用 sum()时需注意 NPE 问题</li><li>NULL 与任何值的直接比较都为 NULL</li><li>在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句</li><li>不得使用外键与级联，一切外键概念必须在应用层解决</li><li>数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认<br>无误才能执行更新语句</li><li>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明</li><li>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出</li><li>更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间</li><li>@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需<br>要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在和实验室的同学一起给学校教务处做一个教学工作量统计系统，在团队一起合作开发及测试的过程中，我认识到了自己在开发规范方面的不足，虽然以前就看过&lt;strong&gt;阿里巴巴Java 约规手册&lt;/strong&gt;，但是我在平时自己做项目、学习的过程中并没有很注意，只遵守驼峰命名等
      
    
    </summary>
    
    
      <category term="开发规范" scheme="http://wang818.top/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="阿里巴巴Java 约规手册" scheme="http://wang818.top/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java-%E7%BA%A6%E8%A7%84%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>位运算之两数相除 </title>
    <link href="http://wang818.top/2019/12/24/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%20/"/>
    <id>http://wang818.top/2019/12/24/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%20/</id>
    <published>2019-12-24T11:46:14.404Z</published>
    <updated>2019-12-24T11:46:05.966Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode 上第29题两数相除，刚开始的时候我的思路是通过while 循环和加减法来实现，后来在编码实现的时候对于除数和被除数的符号相同时可以得出正确答案，但是符号不同时就会出现错误。在评论区看一些大佬的解题思路让我受益匪浅，其中我认为较好的一种思路是使用位运算，用左移去减，因为整数边界问题比较麻烦，所以改用负数计算。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ^ 是异或运算符，相同为0 不同为1</span></span><br><span class="line">        <span class="keyword">boolean</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将整数全部转化为负数再进行运算</span></span><br><span class="line">        <span class="keyword">if</span>(dividend&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(divisor&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        divisor = -divisor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(dividend &lt;= divisor) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp_result = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> temp_divisor = divisor;</span><br><span class="line">            <span class="comment">// // 左移一位相当于乘以二，右移一位相当于除以二</span></span><br><span class="line">            <span class="keyword">while</span>(dividend &lt;= (temp_divisor &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp_divisor &lt;= (Integer.MIN_VALUE &gt;&gt; <span class="number">1</span>))<span class="keyword">break</span>;</span><br><span class="line">                temp_result = temp_result &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                temp_divisor = temp_divisor &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dividend = dividend - temp_divisor;</span><br><span class="line">            result += temp_result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!sign) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result &lt;= Integer.MIN_VALUE) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            result = - result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于我对java 中位运算符不是很了解，就去查了一下资料，以下是关于<strong>java 中^、&amp;、| 和位运算符的含义：</strong></p><ul><li><p><strong>^（异或运算符）</strong><br>  ^ 是针对二进制的二目运算符。运算规则：两个二进制数值如果在同一位上相同，则结果中该位为0，否则为1，比如1011 ^ 0010 = 1001。</p></li><li><p><strong><em>|（或运算符）</em></strong><br> | 是针对二进制的二目运算符。运算规则：两个二进制数值如果在同一位上至少有一个1，则结果中该位为1，否则为0，比如1011 | 0010 = 1011。</p></li><li><p><strong><em>&amp;（与运算符）</em></strong><br> &amp;是是针对二进制的二目运算符。需要注意的是&amp;&amp;是java中判断条件之间表示“和”的标识符，&amp;是一个二目运算符，两个二进制数值如果在同一位上都是1，则结果中该位为1，否则为0，可以认为两个都是true(1)，结果也为true(1)，比如1011 &amp; 0110 = 0010。</p></li><li><p><strong>位运算符</strong></p><ul><li><em>&gt;&gt;x（常数）: 向右移动x位（顶点在哪个方向就往哪个方向移动），如果该数是正数，则高位（最左边）补x个0，如果是负数，则最高位补x个1。*</em><ul><li>*&lt;&lt;x（常数）: 向左移动x位（顶点在哪个方向就往哪个方向移动），无论正负数低位（最右边）都补x个0**</li><li>*&lt;&lt;&lt;: 无该表示方式 **</li><li><em>&gt;&gt;&gt;x(常数): 表示无符号右移x位，所谓无符号是与&gt;&gt;x对比，该操作在移动后，无论正负数高位（最左边）都补0。*</em></li></ul></li></ul></li></ul><p><strong>简单来说，左移一位相当于乘以x，右移一位相当于除以x.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;leetcode 上第29题两数相除，刚开始的时候我的思路是通过while 循环和加减法来实现，后来在编码实现的时候对于除数和被除数的符号相同时可以得出正确答案，但是符号不同时就会出现错误。在评论区看一些大佬的解题思路让我受益匪浅，其中我认为较好的一种思路是使用位运算，用左
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二叉树的定义及遍历</title>
    <link href="http://wang818.top/2019/12/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E9%81%8D%E5%8E%86/"/>
    <id>http://wang818.top/2019/12/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E9%81%8D%E5%8E%86/</id>
    <published>2019-12-24T11:42:35.380Z</published>
    <updated>2019-12-24T11:35:51.108Z</updated>
    
    <content type="html"><![CDATA[<p>最近在刷算法题的过程中发现以前学过的一些数据结构方面的知识有些遗忘了，就开始复习数据结构。</p><p>在计算机科学中，二叉树（binaryTree）是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p><p>以下是关于二叉树的创建及其递归和非递归的三种遍历方式，在刷算法题的过程中发现二叉树可以运用在多种场景下，在运用得当的情况下可以极大提升程序的效率，但万丈高楼平地起，只有对二叉树基础定义、实现及遍历足够了解，才能将其运用得当。</p><ul><li>二叉树的结点定义类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"> Node leftChild;</span><br><span class="line"> Node rightChild;</span><br><span class="line"> <span class="keyword">int</span> data;</span><br><span class="line"> </span><br><span class="line"> Node(<span class="keyword">int</span> data) &#123;</span><br><span class="line"> leftChild = <span class="keyword">null</span>;</span><br><span class="line"> rightChild = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">this</span>.data = data;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><pre><code>由于二叉树具有天然的递归结构，因此在二叉树的创建及遍历过程中使用递归是不错的方法。</code></pre><ul><li>二叉树的创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建二叉树</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> <span class="comment">// 将数组中的值依次转化为二叉树的结点</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"> nodeList.add(<span class="keyword">new</span> Node(array[i]));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length/<span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line"> nodeList.get(i).leftChild = nodeList.get(<span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line"> nodeList.get(i).rightChild = nodeList.get(<span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> lastIndex = array.length/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"> nodeList.get(lastIndex).leftChild = nodeList.get(<span class="number">2</span> * lastIndex + <span class="number">1</span>);</span><br><span class="line"> <span class="comment">// 判断是否有右节点</span></span><br><span class="line"> <span class="keyword">if</span>(array.length % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line"> nodeList.get(lastIndex).rightChild = nodeList.get(<span class="number">2</span> * lastIndex + <span class="number">2</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong><em>二叉树的遍历方式分为先序、中序及后续遍历，每种遍历方式都可以通过递归和非递归两种方式完成</em>。</strong></p><pre><code>递归方式的先序、中序及后续遍历</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line"> preOrderTraverse(node.leftChild);</span><br><span class="line"> preOrderTraverse(node.rightChild);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 中序遍历</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> inOrderTraverse(node.leftChild);</span><br><span class="line"> System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line"> inOrderTraverse(node.rightChild);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 后序 遍历</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> afterOrderTraverse(node.leftChild);</span><br><span class="line"> afterOrderTraverse(node.rightChild);</span><br><span class="line"> System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><pre><code>非递归方式的先序、中序及后续遍历</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归前序遍历</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> Node temp = node;</span><br><span class="line"> Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"> <span class="comment">// 根节点入栈</span></span><br><span class="line"> s.push(temp);</span><br><span class="line"> <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line"> <span class="comment">// 1. 访问根节点</span></span><br><span class="line"> Node pop = s.pop();</span><br><span class="line"> System.out.print(pop.data + <span class="string">" "</span>);</span><br><span class="line"> <span class="comment">// 2. 若根节点存在右孩子结点，将其入栈</span></span><br><span class="line"> <span class="keyword">if</span>(pop.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line"> s.push(pop.rightChild);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 3. 若根节点存在左孩子结点，将其入栈</span></span><br><span class="line"> <span class="keyword">if</span>(pop.leftChild != <span class="keyword">null</span>) &#123;</span><br><span class="line"> s.push(pop.leftChild);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 非递归中序遍历</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> Node temp = node;</span><br><span class="line"> Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"> <span class="keyword">while</span>(temp != <span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line"> <span class="comment">// 1. 将根节点入栈</span></span><br><span class="line"> <span class="comment">// 2. 将所有左孩子入栈</span></span><br><span class="line"> <span class="keyword">while</span>(temp != <span class="keyword">null</span>) &#123;</span><br><span class="line"> s.push(temp);</span><br><span class="line"> temp = temp.leftChild;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 3. 访问栈顶元素</span></span><br><span class="line"> temp = s.pop();</span><br><span class="line"> System.out.print(temp.data + <span class="string">" "</span>);</span><br><span class="line"> <span class="comment">// 4. 若栈顶元素存在右孩子结点，则将右孩子赋值给temp,也就是将右孩子入栈</span></span><br><span class="line"> <span class="keyword">if</span>(temp.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line"> temp = temp.rightChild;</span><br><span class="line"> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"> temp = <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 非递归后序遍历</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 当前结点</span></span><br><span class="line"> Node temp = node;</span><br><span class="line"> <span class="comment">// 上一次访问的结点;</span></span><br><span class="line"> Node prev = <span class="keyword">null</span>;</span><br><span class="line"> Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"> <span class="keyword">while</span>(temp != <span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line"> <span class="comment">// 1. 将根结点及其左孩子入栈</span></span><br><span class="line"> <span class="keyword">while</span>(temp != <span class="keyword">null</span>) &#123;</span><br><span class="line"> s.push(temp);</span><br><span class="line"> temp = temp.leftChild;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(!s.isEmpty()) &#123;</span><br><span class="line"> <span class="comment">// 2. 获取栈顶元素值</span></span><br><span class="line"> temp = s.peek();</span><br><span class="line"> <span class="comment">// 3. 没有右孩子，或者右孩子已经被访问过</span></span><br><span class="line"> <span class="keyword">if</span>(temp.rightChild == <span class="keyword">null</span> || temp.rightChild == prev) &#123;</span><br><span class="line"> temp = s.pop();</span><br><span class="line"> System.out.print(temp.data + <span class="string">" "</span>);</span><br><span class="line"> <span class="comment">// 标记上一次访问的结点</span></span><br><span class="line"> prev = temp;</span><br><span class="line"> temp = <span class="keyword">null</span>;</span><br><span class="line"> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 存在没有被访问的右孩子</span></span><br><span class="line"> temp = temp.rightChild;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在刷算法题的过程中发现以前学过的一些数据结构方面的知识有些遗忘了，就开始复习数据结构。&lt;/p&gt;
&lt;p&gt;在计算机科学中，二叉树（binaryTree）是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动态规划算法</title>
    <link href="http://wang818.top/2019/12/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
    <id>http://wang818.top/2019/12/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</id>
    <published>2019-12-24T11:42:35.376Z</published>
    <updated>2019-12-24T11:34:58.612Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。</p><p>利用动态规划原理解决问题的大致步骤为：</p><ol><li>确认原问题和子问题</li><li>确认状态</li><li>确认边界状态的值</li><li>确定状态转移方程</li></ol><p>以下是我在leetcode上刷的关于动态规划的几道习题的代码和思路</p><ul><li><strong>爬楼梯—-leetcode70</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 爬楼梯----leetcode70</span></span><br><span class="line"><span class="comment"> * 动态规划原理</span></span><br><span class="line"><span class="comment"> * 1. 确认原问题和子问题</span></span><br><span class="line"><span class="comment"> * 原问题是求 n 阶台阶所有走法的数量，子问题是求 1、2、3....n-1</span></span><br><span class="line"><span class="comment"> * 阶台阶的走法</span></span><br><span class="line"><span class="comment"> * 2. 确认状态</span></span><br><span class="line"><span class="comment"> * 本题的动态规划状态单一，第i个状态即为i阶台阶的所有走法数量</span></span><br><span class="line"><span class="comment"> * 3. 确认边界状态的值</span></span><br><span class="line"><span class="comment"> * 边界状态为1阶台阶和2阶台阶的走法，1阶台阶有1种走法，2阶台阶有2种走法，即dp[0]=1,dp[1]=2</span></span><br><span class="line"><span class="comment"> * 4. 确定状态转移方程</span></span><br><span class="line"><span class="comment"> * 将求第i 个状态的值转化为求第i-1 个状态的值和第i-2 个状态的值，</span></span><br><span class="line"><span class="comment"> * 动态规划转换方程为 ：dp[i]=dp[i-1]+dp[i-2]</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>打家劫舍—leetcode198</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打家劫舍---leetcode198</span></span><br><span class="line"><span class="comment"> * 动态规划原理</span></span><br><span class="line"><span class="comment"> * 1. 确认原问题和子问题</span></span><br><span class="line"><span class="comment"> * 原问题为n 个房间的最优解，子问题为求前1个房间、前两个房间、前n-1个房间的最优解</span></span><br><span class="line"><span class="comment"> * 2. 确认状态</span></span><br><span class="line"><span class="comment"> * 第i 个状态即为前i 能够获得的最大财宝（最优解）个房间</span></span><br><span class="line"><span class="comment"> * 3. 确认边界状态的值</span></span><br><span class="line"><span class="comment"> * 前1个房间的最优解为第1个房间的财宝</span></span><br><span class="line"><span class="comment"> * 前2个房间的最优解为第1、2个房间中财宝的较大值</span></span><br><span class="line"><span class="comment"> * 4. 确定状态转移方程</span></span><br><span class="line"><span class="comment"> * a. 选择第i 个房间：第i 个房间 + 前i-2 个房间的最优解</span></span><br><span class="line"><span class="comment"> * b. 选择第i-1 个房间：前i-1 个房间的最优解</span></span><br><span class="line"><span class="comment"> * 动态规划转移方程：</span></span><br><span class="line"><span class="comment"> * dp[i] = max(dp[i-1], dp[i-2] + nums[i])</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums.length == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums.length == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>最大子序和—leetcode53</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 最大子序和---leetcode53</span></span><br><span class="line"><span class="comment"> * 动态规划原理</span></span><br><span class="line"><span class="comment"> * 1. 确认原问题和子问题</span></span><br><span class="line"><span class="comment"> * 原问题为在数组中找到一个具有最大和的连续子数组，</span></span><br><span class="line"><span class="comment"> * 子问题为找到以原数组中每个元素结尾的子数组的最优解</span></span><br><span class="line"><span class="comment"> * 2. 确认状态</span></span><br><span class="line"><span class="comment"> * 第i 个状态即为以第i 个数字结尾的最优解</span></span><br><span class="line"><span class="comment"> *3. 确认边界状态的值</span></span><br><span class="line"><span class="comment"> *以第一个数字结尾的最大字段和dp[0]=nums[0]</span></span><br><span class="line"><span class="comment"> *4. 确定状态转移方程</span></span><br><span class="line"><span class="comment"> *a. 当dp[i-1]&gt;0：dp[i] = dp[i-1]+nums[i]</span></span><br><span class="line"><span class="comment"> *b. 当dp[i-1]&lt;0：dp[i] = nums[i];</span></span><br><span class="line"><span class="comment"> *dp[i] = max(dp[i-1]+nums[i], nums[i])</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums.length == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>]+nums[<span class="number">1</span>], nums[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">dp[i] = Math.max(dp[i-<span class="number">1</span>]+nums[i], nums[i]);</span><br><span class="line"><span class="keyword">if</span>(dp[i] &gt; max) &#123;</span><br><span class="line">max = dp[i];</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>零钱兑换—leetcode322</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 零钱兑换---leetcode322</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> * dp[i]数组用来表示0到amount数额之间的每个值所需的最小硬币数量</span></span><br><span class="line"><span class="comment"> * 因为数组下标是从0开始的，因此dp数组的长度应该为amount+1</span></span><br><span class="line"><span class="comment"> * 设 coins为[1, 2, 5],amount=11,则dp[0]=0, dp[1]=1,dp[2]=1,dp[3]=2,dp[4]=2,</span></span><br><span class="line"><span class="comment"> * dp[5]=1, dp[6]=2, dp[7]=2, dp[8]=3, dp[9]=3, dp[10]=2, dp[11]=3,</span></span><br><span class="line"><span class="comment"> * 因此当amount为11时的结果为3</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(coins == <span class="keyword">null</span> || coins.length == <span class="number">0</span> || amount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">dp[i] = amount+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(coins[j] &lt;= i) &#123;</span><br><span class="line">dp[i] = Math.min(dp[i], dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>三角形最小路径和—leetcode120（经典动态规划练习题）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 三角形最小路径和---leetcode120（经典动态规划练习题）</span></span><br><span class="line"><span class="comment"> * 算法思路：</span></span><br><span class="line"><span class="comment"> * 1.设置一个二维数组，最优值三角形dp[][]，并初始化数组元素为0，</span></span><br><span class="line"><span class="comment"> *   dp[i][j]代表了数组三角形第i行， 第j列的最优解（从底往上推）</span></span><br><span class="line"><span class="comment"> * 2.从三角形的地面向三角形上方进行动态规划</span></span><br><span class="line"><span class="comment"> * a. 动态规划边界条件：地面上的最优解的即为数字三角形的最后一层</span></span><br><span class="line"><span class="comment"> * b. 利用i循环，从倒数第二层递推至正数第一层，对于每层的各列，进行动态规划递推：</span></span><br><span class="line"><span class="comment"> *         第i行， 第j列的最优解为dp[i][j]，可到达(i, j)的两个位置的最优解为</span></span><br><span class="line"><span class="comment"> *    dp[i+1][j]、dp[i+1]dp[j+1]</span></span><br><span class="line"><span class="comment"> *        状态转换方程为：dp[i][j]=min(dp[i+1][j], dp[i+1][j+1])+triangle[i][j]</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(triangle == <span class="keyword">null</span> || triangle.size() == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.size()][triangle.size()];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"> List&lt;Integer&gt; list = triangle.get(i);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line"> dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j], dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+list.get(j);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>最长上升子序列—leetcode300</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 最长上升子序列---leetcode300</span></span><br><span class="line"><span class="comment">  * 动态规划</span></span><br><span class="line"><span class="comment">  * 若第i个状态dp[i]代表以第i个元素结尾的最大上升子序列的长度：</span></span><br><span class="line"><span class="comment">  * dp[i-1]代表以第i-1个元素结尾的最大上升子序列的长度</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"> dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"> <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line"> max = Math.max(max, dp[j]);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> dp[i] = max + <span class="number">1</span>;</span><br><span class="line"> maxlen = Math.max(maxlen, dp[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> maxlen;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>最小路径和—leetCode64</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 最小路径和---leetCode64</span></span><br><span class="line"><span class="comment">  * 和三角形的最小路径和相似（但是要注意边界条件的判断）</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length+<span class="number">1</span>][grid[<span class="number">0</span>].length+<span class="number">1</span>];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = grid.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j = grid[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == grid.length - <span class="number">1</span> &amp;&amp; j != grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = grid[i][j] +  dp[i][j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j != grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = grid[i][j] + Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = grid[i][j];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java设计模式之单例模式</title>
    <link href="http://wang818.top/2019/12/24/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wang818.top/2019/12/24/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-12-24T11:42:35.350Z</published>
    <updated>2019-12-24T11:31:59.536Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）属于创建型模式，它提供了一种创建对象较好的方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时保证只有单个对象被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>注意：</p><ol><li><p>一个类只能有一个实例</p></li><li><p>单例类必须自己创建自己的唯一实例。</p></li><li><p>单例类必须给所有其他对象提供这一实例。</p><p>单例模式的目的：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>主要解决：一个全局使用的类频繁地创建与销毁。</p><p>使用场景：向想确保任何情况下都只有一个实例（线程池、数据库连接池等）</p><p>优点：在内存里只有一个实例，减少了内存开销、可以避免对资源的多重占用、设置全局            访问点，严格控制访问</p><p>缺点：没有接口、扩展困难</p><p>重点：私有构造器、线程安全、延迟加载、序列化和反序列化安全、反射</p><p>相关设计模式：单例模式和工厂模式、单例模式和享元模式</p></li></ol><p><strong>单例模式的集中实现方式：</strong></p><ul><li>懒汉式（线程不安全）<br>懒汉式单例模式，顾名思义，这种单例模式很懒，在初始化的时候不创建，而是做一个延迟加载。这种实现方式最大的问题是在多线程的场景下不安全，没有加 synchronized 锁 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lazySingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lazySingleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DoubleCheck双重检查实现懒汉式（线程安全）<br>上述延迟加载的模式在多线程的情况下是不安全的，为了解决多线程问题，可以采用DoubleCheck双重检查实现懒汉式。这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是效率很低。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckSingleton lazyDoubleCheckSingleton = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lazyDoubleCheckSingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (LazyDoubleCheckSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lazyDoubleCheckSingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">lazyDoubleCheckSingleton = <span class="keyword">new</span> LazyDoubleCheckSingleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lazyDoubleCheckSingleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态内部类（线程安全）<br>基于类初始化的延迟加载，这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line"><span class="comment">// InnerClass类的对象的初始化锁被哪个线程拿到，那个线程负责实例化对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassSingleton staticInnerClassSingleton = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> InnerClass.staticInnerClassSingleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>饿汉式（线程安全）<br>在类加载的时候就完成类的实例化。这种方式比较常用，但容易产生垃圾对象。它没有加锁，执行效率会提高，但是类加载时就初始化，浪费内存。它基于 classloader 机制避免了多线程的同步问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton hungrySingleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> hungrySingleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>序列化破坏单例模式原理解析及解决方案（以饿汉式为例）<br>在序列化和反序列化之后拿到的不是同一个对象。这是因为ObjectInputStream 对象的readObject()方法调用了readObject0()方法，而当ObjectInputStream 读入的是对象时，readObject0()方法中的 readOrdinaryObject(unshared)方法会调用isInstantiable()方法，isInstantiable()方法在类运行时被实例化时会返回true,然后会调用newInstance()方法，这样就通过反射又创建了一个对象，所以在序列化和反序列化之后拿到的不是同一个对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singleton_file"</span>));</span><br><span class="line">oos.writeObject(instance);</span><br><span class="line"></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"singleton_file"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">HungrySingleton newInstance = (HungrySingleton)ois.readObject();</span><br><span class="line"></span><br><span class="line">System.out.println(instance);</span><br><span class="line">System.out.println(newInstance);</span><br><span class="line"><span class="comment">// 结果为 false ,说明两者不是同一个对象，这就违背了单例设计模式</span></span><br><span class="line">System.out.println(instance == newInstance);</span><br><span class="line">oos.close();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton hungrySingleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> hungrySingleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> hungrySingleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反射攻击解决方案及原理分析（以饿汉式为例）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = HungrySingleton<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();</span><br><span class="line">System.out.println(instance);</span><br><span class="line">System.out.println(newInstance);</span><br><span class="line"><span class="comment">// 结果为 false ,说明两者不是同一个对象，这就违背了单例设计模式</span></span><br><span class="line">System.out.println(instance == newInstance);</span><br></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton hungrySingleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(hungrySingleton != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射调用"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> hungrySingleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Enum枚举单例（线程安全）<br>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumInstance &#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="keyword">private</span> Object date;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Object date)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.date = date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>容器单例模式（线程安全问题取决于具体的实现）<br>容器单例的思路是这样的，维护一个Map，把单例的实例都存放进该Map中，用的时候只从该Map中取，试图实现单例；但这种思路有局限性，Map中存的单例对象是可以被更新掉的，如果两次取的间隔，发生了单例对象的更新，就会取到2个不同的对象，破坏了单例性；</p><p> 应用场景：如果程序中单例类很多，可以考虑用一个容器管理起来；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; singletonMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(); </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putInstance</span><span class="params">(String key, Object instance)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(!singletonMap.containsKey(key)) &#123;</span><br><span class="line">singletonMap.put(key, instance);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> singletonMap.get(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ThreadLocal 线程“单例模式”<br>不是传统意义中的单例模式，不同线程之间拿到的对象可能不同，但是每个线程中对象都是单例的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例模式（Singleton Pattern）属于创建型模式，它提供了一种创建对象较好的方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时保证只有单个对象被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。&lt;/p&gt;
&lt;p&gt;注意：&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java设计模式之代理模式</title>
    <link href="http://wang818.top/2019/12/24/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wang818.top/2019/12/24/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-12-24T11:42:35.347Z</published>
    <updated>2019-12-24T11:22:26.534Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式（Proxy Pattern）为其他对象（类）提供一种代理，以控制对这个对象（类）的访问。代理对象在客户端和目标对象之间起到中介的作用。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p><p>当直接访问对象会遇到一些问题时，例如：有些对象由于一些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），这时直接访问就不是一种好的选择。</p><p>代理的思想在实际中也有很多的运用，例如：Windows快捷方式，Spring AOP的实现。</p><p>代理模式的应用场景：保护目标对象（控制对目标对象的访问）、增强目标对象</p><p>代理模式的优点：</p><ul><li>代理模式能将代理对象与真实被调用的目标对象分离</li><li>一定程度上降低了系统的耦合度，扩展性好</li><li>保护目标对象</li><li>增强目标对象</li></ul><p>代理模式的缺点：</p><ul><li>代理模式会造成系统设计中类的数目增加</li><li>在客户端和目标对象间增加一个代理对象，会造成请求处理速度变慢</li><li>增加系统的复杂度</li></ul><p>相关设计模式：装饰者模式、适配器模式</p><p>注意：</p><ul><li>适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口</li><li>装饰器模式为了增强功能，而代理模式是为了加以控制</li></ul><p>代理分为静态代理和动态代理，而动态代理又有两种实现方式：</p><ul><li>JDK动态代理（无法代理类，只能代理接口）</li><li>CGLib代理（通过继承，使用时要注意final修饰符）</li></ul><p>接下来，我用一个简易下单的方式对代理模式进行实现</p><ul><li>静态代理<br>步骤一：创建一个实体对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object orderInfo;</span><br><span class="line"><span class="keyword">private</span> Integer userId;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getOrderInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> orderInfo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderInfo</span><span class="params">(Object orderInfo)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.orderInfo = orderInfo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userId = userId;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 步骤二：创建一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOrderService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤三：创建接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">IOrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IOrderDao orderDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">orderDao = <span class="keyword">new</span> OrderDaoImpl();</span><br><span class="line">System.out.println(<span class="string">"service层调用dao层方法添加订单"</span>);</span><br><span class="line"><span class="keyword">return</span> orderDao.insert(order);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤四：创建dao层接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOrderDao</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤五：创建dao层接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title">IOrderDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Dao层添加Order成功"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK静态代理实现之创建静态代理类</strong></p><ul><li>java.lang.reflect.Proxy:生成动态代理类和对象；</li><li>java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceStaticProxy</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> IOrderService iOrderService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对IOrderService接口中的方法进行增强</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">beforeMethod(order);</span><br><span class="line">iOrderService = <span class="keyword">new</span> OrderServiceImpl();</span><br><span class="line">afterMethod();</span><br><span class="line"><span class="keyword">int</span> result = iOrderService.saveOrder(order);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"静态代理 before code"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"静态代理 after code"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK动态代理实现之创建动态代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceDynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderServiceDynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;? extends Object&gt; cls = target.getClass();</span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(cls.getClassLoader(), cls.getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Object argObject = args[<span class="number">0</span>];</span><br><span class="line">beforeMethod(argObject);</span><br><span class="line">Object object = method.invoke(target, args);</span><br><span class="line">afterMethod();</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"动态代理 before code"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"动态代理 after code"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Cglib 动态代理</strong><br>Cglib 动态代理是针对代理的类, 动态生成一个子类, 然后子类覆盖代理类中的方法, 如果是private或是final类修饰的方法,则不会被重写。</p><p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。两者没有什么本质的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理模式（Proxy Pattern）为其他对象（类）提供一种代理，以控制对这个对象（类）的访问。代理对象在客户端和目标对象之间起到中介的作用。这种类型的设计模式属于结构型模式。&lt;br&gt;在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。&lt;/p&gt;
&lt;p&gt;当直接
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>引言</title>
    <link href="http://wang818.top/2019/12/24/%E5%BC%95%E8%A8%80/"/>
    <id>http://wang818.top/2019/12/24/%E5%BC%95%E8%A8%80/</id>
    <published>2019-12-24T11:42:35.318Z</published>
    <updated>2019-12-24T11:39:46.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>   明天是学校正式开学的一天，我也要迎来了自己的大三生活。我学的专业是计算机科学与技术，从大一下学期接触到java时，我就对其产生了很大的兴趣，然后一直在学习关于java方面的知识。注册CSDN已经很长时间了，但是这是第一次写博客，以前在学习的时候也想着写博客，但是那时自己的整体学习路线还没有梳理清楚，写的博客也类似于笔记，并没有太大的意义。目前在经过一年半的学习后，我对J2EE开发的大体架构和学习路线也有了更深的认识，因此开始写博客来对所学的知识进行梳理与总结。<br>    在大一下的学期，我重点学习了java基础知识，比如：标识符和数据类型、表达式和流程控制语句、数组、向量和字符串、对象和类、异常、IO。在这个阶段我并没有对java的多线程、高并发、网络功能以及最底层的java虚拟机、代码安全、垃圾收集机制、集合框架的源码进行深入的了解，就进入了J2EE的学习。<br>    在大一下的暑假，我学习了html、css、js、jsp、Bootstrap、jQuery、JDBC、mysql、Servlet、tomcat、ajax、xml、json、拦截器、过滤器等基础Web开发知识。然后用一个月的时间学习了SpringMVC、Spring、Mybatis三个框架，并将其整合做了个小型的网站。在整合SSM框架时，遇到了各种各样因为jar包冲突而引起的问题，因此我开始学习maven（后来又学了gradle进行构建，个人感觉gradle好用一些）来构建代码和项目管理。当时实验室的学长告诉我们最好要拥有开发自己的技术博客，这样既可以对平时的学习进行总结，也可以在面试中加分。所有我就开始开发属于自己的博客网站。因为是第一次写一个完整的网站，所以在开发过程中遇到各种问题。因为要实现网站的搜索功能，我开始学习全文检索（Lucene、ElasticSearch）。在这个过程中我用了大概三个月的时间。到此，我的大一生涯也结束了。<br>    在大二上的学期开设了数据结构与算法分析课程，数据结构和算法对于从事计算机的人的重要性众所周知。因此，我在这上面也投入了很多精力。对着微服务的概念越来越被认可，同时自己也觉得Spring框架的配置十分繁琐，于是就去了解了关于SpringBoot的知识。<br>    在大二下的学期，我开始了解关于缓存、高并发、分布式的相关知识。关于缓存，我着重学习了redis，在这过程中对于缓存设计的目的、缓存的持久化、缓存复制的原理、缓存的更新、穿透和无底洞、redis的高可用以及redis集群等有了一定的认识。在高并发方面，我写了一个秒杀系统，使用redis作为缓存，RabbitMQ作为消息队列以及页面静态化来减小对数据库访问的压力，提高系统的QPS。关于分布式，我了解了分布式的基本概念以及分布式系统解决的问题以及在设计分布式系统中应该注意的问题。但是我对于分布式的理解还是很浅，需要更加深入的去了解。<br>    马上就要步入大三上，我学习的方向是深入多线程、了解java最底层的知识（java虚拟机、CG等）、MySQL调优、学习一些基本的设计模式、看一些源码（Spring、Hashmap等）从而了解那些是如何写代码的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;   明天是学校正式开学的一天，我也要迎来了自己的大三生活。我学的专业是计算机科学与技术，从大一下学期接触到java时，我就对其产生了很大的
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
