<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java主流锁之悲观锁和乐观锁的简单模拟实现</title>
    <url>/2019/12/29/java%E4%B8%BB%E6%B5%81%E9%94%81%E4%B9%8B%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在上一篇文章<a href="https://blog.csdn.net/wangbo818/article/details/103747333" target="_blank" rel="noopener">java主流锁之悲观锁和乐观锁</a>中，我们已经知道了什么是乐观锁和悲观锁以及他们的实现方式和使用场景。</p>
<p>现在就来简单模拟实现悲观锁和乐观锁</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p><strong>首先在数据库中创建一张goods 表</strong><br><img src="https://img-blog.csdnimg.cn/20191228224524227.png" alt="创建goods表"><br><strong>向数据库中插入一条记录</strong><br><img src="https://img-blog.csdnimg.cn/20191228224657968.png" alt="插入数据"><br><strong>如果要进行减少count 操作的话，则首先查询出count 数量，若count 数量大于0，则可以进行修改操作。悲观锁是在查询的时候就将该条记录锁定</strong><br><img src="https://img-blog.csdnimg.cn/20191229152215694.png" alt="开启事务"><br><strong>此时其他的客户端只能进行查询操作，而无法进行其他任何操作</strong><br><img src="https://img-blog.csdnimg.cn/20191229152309174.png" alt="阻塞"><br><strong>只有等拿到锁的客户端提交事务，另一个客户端才可以再对其进行修改等操作</strong><br><img src="https://img-blog.csdnimg.cn/20191229152431998.png" alt="commit"><br><img src="https://img-blog.csdnimg.cn/20191229152505737.png" alt="修改成功"></p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><strong>首先在数据库中创建goods 表，但是与悲观锁不同的是在创建表的时候添加一个version 字段</strong><br><img src="https://img-blog.csdnimg.cn/2019122823063249.png" alt="创建goods表"><br><strong>向goods 表中插入一条记录</strong><br><img src="https://img-blog.csdnimg.cn/20191228231525447.png" alt="添加记录"><br><strong>此时如果要减少count 的话，则首先查询出count 数量，若count 数量大于0，则可以进行修改操作</strong><br><img src="https://img-blog.csdnimg.cn/20191228231839465.png" alt="查询库存"><br><img src="https://img-blog.csdnimg.cn/2019122823305733.png" alt="修改"><br><strong>此时另外开启一个MySQL 客户端，进行同样的修改操作，因为版本号不一致，所以修改失败</strong><br><img src="https://img-blog.csdnimg.cn/20191228233204609.png" alt="修改失败"><br><strong>此时用正确的版本号去修改，可以看到修改成功</strong><br><img src="https://img-blog.csdnimg.cn/20191228233344744.png" alt="修改成功"></p>
]]></content>
  </entry>
  <entry>
    <title>java主流锁之乐观锁和悲观锁</title>
    <url>/2019/12/28/java%E4%B8%BB%E6%B5%81%E9%94%81%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<p>java提供了很多种类的锁，每种锁都有其特性，根据特性在适当的场景下能够展现出非常高的效率。</p>
<p>下图来源于<a href="https://zhuanlan.zhihu.com/p/50098743" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50098743</a><br><img src="https://img-blog.csdnimg.cn/20191228183759965.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="java主流锁"><br>在一个高并发秒杀的场景下中，很有可能会出现超卖的情况，要解决超卖的问题，可以对数据库中的表或记录加锁。我刚开始在秒杀项目中是用悲观锁来解决超卖的问题，但是在并发量很高的情况，悲观锁的效率可能不是很好，因此，我改用乐观锁来代替悲观锁。那么，什么是乐观锁和悲观锁呢？乐观锁在并发量很高的情况下性能为什么要优于悲观锁呢？怎样简单实现乐观锁和悲观锁呢（下一篇文章中实现）？</p>
<h2 id="什么是悲观锁和乐观锁？"><a href="#什么是悲观锁和乐观锁？" class="headerlink" title="什么是悲观锁和乐观锁？"></a>什么是悲观锁和乐观锁？</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>正如其名，它指的是对数据被外界（包括本系统的其它事务，以及来自外部系统的事务处理）修改持保守态度，因此，每次对数据进行操作时，都会将数据置为被锁定状态，这样别的事务想要拿到这个数据都会阻塞。悲观的实现，往往依靠数据库提供的锁机制（也只有数据库提供的锁机制才能真正保证数据访问的排他性）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其他事务只能读数据，而不能修改、删除数据。当修改删除数据时也要加锁，此时其他事务无法读取数据。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>相对悲观锁而言，乐观锁采取了更为宽松的锁机制。悲观锁大部分情况下都要依靠数据库的锁机制实现，以保证操作的独占性。但是随之而来的就是数据库性能的大幅度开销，特别是对长事务来说，这样的开销往往无法接受。</p>
<p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，顾名思义，总是假设最好的情况，每次去拿数据的时候都认为只有自己一个人拿，因此就不会加锁，但是在更新的时候会判断在自己操作数据期间，有没有其他人操作过数据。</p>
<p>乐观锁，大多是基于数据版本（Version）记录机制实现的。那什么是数据版本？数据版本就是为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过给数据库表增加一个”Version” 字段来实现。读取数据时，将此版本号一起读出，之后更新时，将此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<p>除了使用版本号机制外，还可以使用CAS算法来实现乐观锁。例如：在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的CAS实现方式实现的。</p>
<h3 id="乐观锁和悲观锁的使用场景"><a href="#乐观锁和悲观锁的使用场景" class="headerlink" title="乐观锁和悲观锁的使用场景"></a>乐观锁和悲观锁的使用场景</h3><p>从以上对两种锁的介绍可以知道两种锁各有其有优缺点，不能认为一种好于另一种，只是说适用于不同的场景。像乐观锁适用于写比较少的场景（多读场景），即冲突真的很少发生的时候，这样就省去了锁的开销，加到了系统的整个吞吐量。但如果是多写的情况，一般会经常发生冲突，这会导致上层的应用会不断地进行retry，这样反倒是降低了性能。所以一般多写的场景下使用悲观锁。</p>
<h3 id="乐观锁实现方式"><a href="#乐观锁实现方式" class="headerlink" title="乐观锁实现方式"></a>乐观锁实现方式</h3><p>出来上述的基于版本号机制实现乐观锁外，最长是采用CAS（Compare And Swap（比较与交换））算法实现。CAS算法是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）</p>
<p>CAS算法基于三个操作数：</p>
<ul>
<li><p>需要读写的内存值V</p>
</li>
<li><p>进行比较的值A</p>
</li>
<li><p>拟写入的新值B</p>
<p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
</li>
</ul>
<p>当然，虽然CAS算法很高效，但是也会存在很多问题，例如：</p>
<ul>
<li>ABA问题</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作</li>
</ul>
<p>我对这些问题产生的原因和解决方案也了解的不是很清楚，所以如果大家有兴趣的话，可以去查阅相关资料。</p>
]]></content>
  </entry>
  <entry>
    <title>PAT乙级真题题解java实现</title>
    <url>/2019/12/28/PAT%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98%E9%A2%98%E8%A7%A3java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>虽然这次PAT考试的成绩并不算理想，但还是有了很多收获，特别是认识了一些很优秀的人以及他们平时怎么学习算法。</p>
<p>我参加的2019年冬季PAT乙级考试，这个时间PAT官网上的乙级真题有95道，我是使用java来做的（推荐使用c语言）。大部分题都是通过的，部分题目超出时间限制，<br>还有一部分只通过了部分用例。</p>
<p>以下是题目清单及我的通过情况：<br><a href="https://github.com/WangBo0818/PAT" target="_blank" rel="noopener">GitHub仓库</a></p>
<ul>
<li><p>完全正确</p>
<ul>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1001.java" target="_blank" rel="noopener">1001 害死人不偿命的(3n+1)猜想</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1002.java" target="_blank" rel="noopener">1002 写出这个数</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1003.java" target="_blank" rel="noopener">1003 我要通过！</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1004.java" target="_blank" rel="noopener">1004 成绩排名</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1005.java" target="_blank" rel="noopener">1005 继续(3n+1)猜想</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1006.java" target="_blank" rel="noopener">1006 换个格式输出整数</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1007.java" target="_blank" rel="noopener">1007 素数对猜想</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1008.java" target="_blank" rel="noopener">1008 数组元素循环右移问题</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1009.java" target="_blank" rel="noopener">说反话</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1010.java" target="_blank" rel="noopener">1010 一元多项式求导</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1011.java" target="_blank" rel="noopener">1011 A+B 和 C</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1012.java" target="_blank" rel="noopener">1012 数字分类</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1013.java" target="_blank" rel="noopener">1013 数素数</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1016.java" target="_blank" rel="noopener">1016 部分A+B</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1017.java" target="_blank" rel="noopener">1017 A除以B</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1019.java" target="_blank" rel="noopener">1019 数字黑洞</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1020.java" target="_blank" rel="noopener">1020 月饼</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1021.java" target="_blank" rel="noopener">1021 个位数统计</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1022.java" target="_blank" rel="noopener">1022 D进制的A+B</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1023.java" target="_blank" rel="noopener">1023 组个最小数</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1024.java" target="_blank" rel="noopener">1024 科学计数法</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1026.java" target="_blank" rel="noopener">1026     程序运行时间</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1027.java" target="_blank" rel="noopener">1027 打印沙漏</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1029.java" target="_blank" rel="noopener">1029 旧键盘</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1036.java" target="_blank" rel="noopener">1036 跟奥巴马一起编程</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1037.java" target="_blank" rel="noopener">1037     在霍格沃茨找零钱</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1039.java" target="_blank" rel="noopener">1039 到底买不买</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1040.java" target="_blank" rel="noopener">1040 有几个PAT</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1041.java" target="_blank" rel="noopener">1041 考试座位号</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1042.java" target="_blank" rel="noopener">1042 字符统计</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1043.java" target="_blank" rel="noopener">1043 输出PATest</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1044.java" target="_blank" rel="noopener">1044 火星数字</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1046.java" target="_blank" rel="noopener">1046 划拳</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1047.java" target="_blank" rel="noopener">1047 编程团体赛</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1051.java" target="_blank" rel="noopener">1051 复数乘法</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1053.java" target="_blank" rel="noopener">1053 住房空置率</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1054.java" target="_blank" rel="noopener">1054 求平均值</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1055.java" target="_blank" rel="noopener">1055 集体照</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1056.java" target="_blank" rel="noopener">1056 组合数的和</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1057.java" target="_blank" rel="noopener">1057 数零壹</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1061.java" target="_blank" rel="noopener">1061 判断题</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1064.java" target="_blank" rel="noopener">1064 朋友数</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1067.java" target="_blank" rel="noopener">1067 试密码</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1069.java" target="_blank" rel="noopener">1069 微博转发抽奖</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1070.java" target="_blank" rel="noopener">1070 结绳</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1076.java" target="_blank" rel="noopener">1076 Wifi密码</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1077.java" target="_blank" rel="noopener">1077 互评成绩计算</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1078.java" target="_blank" rel="noopener">1078 字符串压缩与解压</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1081.java" target="_blank" rel="noopener">1081 检查密码</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1083.java" target="_blank" rel="noopener">1083 是否存在相等的差</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1084.java" target="_blank" rel="noopener">1084 外观数列</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1086.java" target="_blank" rel="noopener">1086 就不告诉你</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1087.java" target="_blank" rel="noopener">1087 有多少不同的值</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1088.java" target="_blank" rel="noopener">1088 三人行</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1089.java" target="_blank" rel="noopener">1089 狼人杀-简单版</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1090.java" target="_blank" rel="noopener">1090 危险品装箱</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1091.java" target="_blank" rel="noopener">1091 N-自守数</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1093.java" target="_blank" rel="noopener">1093 字符串A+B</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1094.java" target="_blank" rel="noopener">1094 谷歌的招聘</a></li>
</ul>
</li>
<li><p>超出时间限制</p>
<ul>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1015.java" target="_blank" rel="noopener">1015 德才论</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1018.java" target="_blank" rel="noopener">1018 锤子剪刀布</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1025.java" target="_blank" rel="noopener">1025 反转链表</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1030.java" target="_blank" rel="noopener">1030 完美数列</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1032.java" target="_blank" rel="noopener">1032 挖掘机技术哪家强</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1038.java" target="_blank" rel="noopener">1038 统计同成绩学生</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1045.java" target="_blank" rel="noopener">1045 快速排序</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1049.java" target="_blank" rel="noopener">1049 数列的片段和</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1050.java" target="_blank" rel="noopener">1050 螺旋矩阵</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1058.java" target="_blank" rel="noopener">1058 选择题</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1060.java" target="_blank" rel="noopener">1060 爱丁顿数</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1062.java" target="_blank" rel="noopener">1062 最简分数</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1063.java" target="_blank" rel="noopener">1063 计算谱半径</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1065.java" target="_blank" rel="noopener">1065 单身狗</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1066.java" target="_blank" rel="noopener">1066 图像过滤</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1073.java" target="_blank" rel="noopener">1073 多选题常见计分法</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1079.java" target="_blank" rel="noopener">1079 延迟的回文数</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1080.java" target="_blank" rel="noopener">1080 MOOC期终成绩</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1082.java" target="_blank" rel="noopener">1082 射击比赛</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1085.java" target="_blank" rel="noopener">1085 PAT单位排行</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1092.java" target="_blank" rel="noopener">1092 最好吃的月饼</a></li>
<li></li>
</ul>
</li>
<li><p>部分通过</p>
<ul>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1014.java" target="_blank" rel="noopener">1014 福尔摩斯的约会</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1028.java" target="_blank" rel="noopener">1028 人口普查</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1031.java" target="_blank" rel="noopener">1031 查验身份证</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1033.java" target="_blank" rel="noopener">1033 旧键盘打字</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1034.java" target="_blank" rel="noopener">1034 有理数四则运算</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1035.java" target="_blank" rel="noopener">1035 插入与归并</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1048.java" target="_blank" rel="noopener">1048 数字加密</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1059.java" target="_blank" rel="noopener">1059 C语言竞赛</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1068.java" target="_blank" rel="noopener">1068 万绿丛中一点红</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1071.java" target="_blank" rel="noopener">1071 小赌怡情</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1072.java" target="_blank" rel="noopener">1072 开学寄语</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1074.java" target="_blank" rel="noopener">1074 宇宙无敌加法器</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1075.java" target="_blank" rel="noopener">1075 链表元素分类</a></li>
<li><a href="https://github.com/WangBo0818/PAT/blob/master/src/Pat_1095.java" target="_blank" rel="noopener">1095 解码PAT准考证</a></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>阿里巴巴Java 约规手册：码出高效，码出质量</title>
    <url>/2019/12/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%20%E7%BA%A6%E8%A7%84%E6%89%8B%E5%86%8C%EF%BC%9A%E7%A0%81%E5%87%BA%E9%AB%98%E6%95%88%EF%BC%8C%E7%A0%81%E5%87%BA%E8%B4%A8%E9%87%8F/</url>
    <content><![CDATA[<p>最近在和实验室的同学一起给学校教务处做一个教学工作量统计系统，在团队一起合作开发及测试的过程中，我认识到了自己在开发规范方面的不足，虽然以前就看过<strong>阿里巴巴Java 约规手册</strong>，但是我在平时自己做项目、学习的过程中并没有很注意，只遵守驼峰命名等较为基础的约规。在这次的开发过程中，因为开发当中的不规范而导致了很多问题，例如：</p>
<ul>
<li>POJO 类及方法返回值的类型都定义的是 int 等基本类型，而不是 Integer 等引用类型，这样在数据库里的数据为空的情况下或者页面传来null 值的时候，系统就会报错；</li>
<li>在工作量计算时，所需的常量也未使用枚举或类静态常量定义，从而导致程序里有许多魔数，这也会使维护变得困难；</li>
<li>大家都是第一次实际自己设计并实现一个系统，在构想的时候难免不充分，在全局异常处理以及全局返回值定义方面没有统一，这将导致一旦系统出现异常无法做出足够正确的处理</li>
<li>数据库的表结构和索引具有一定的缺陷，这可能会导致系统的架构缺陷和性能风险</li>
</ul>
<p>所以我重新看了阿里巴巴Java 约规手册，在经过这次实战后，我对开发规范的重视程度提高了很多，对为什么要严格遵守约规有了更深入的认识，可能软件工程师与码农的区别不仅仅是技术、架构上差别，还有写出的代码的质量。</p>
<p>以下是约规手册的部分内容概述：</p>
<ul>
<li>代码中的命名均不能以下划线或美元符号开始，也不能以其结束</li>
<li>代码中的命名严禁中英文混合，更不允许使用中文，应使用正确的英文拼写和语法‘’</li>
<li>类名要使用 UpperCamelCase 风格，除了DO / BO / DTO / VO / AO / PO 等领域模型</li>
<li>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从<br>驼峰形式</li>
<li>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚</li>
<li>抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类<br>命名以它要测试的类名开始，以 Test 结尾</li>
<li>类型与中括号紧挨相连来定义数组。例如：String[] args 而不是 String args[]</li>
<li>POJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误</li>
<li>包名统一使用小写，点分隔符之间仅有一个自然语义的英文单词</li>
<li>杜绝绝大部分缩写（个人认为杜绝所有缩写）</li>
<li>命名变量、常量等要做到看文知义</li>
<li>如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式</li>
<li>接口类中的方法和属性不要加任何修饰符号尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量</li>
<li>枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开</li>
<li>Service/DAO 层方法命名规约：获取单个对象的方法用 get 作前缀、获取多个对象的方法用 list 作前缀、获取统计值的方法用 count 作前缀、插入的方法用 save/insert 作前缀、删除的方法用 remove/delete 作前缀、修改的方法用 update 作前缀</li>
<li>领域模型命名规约：数据对象：xxxDO，xxx 即为数据表名；数据传输对象：xxxDTO，xxx 为业务领域相关的名称；展示对象：xxxVO，xxx 一般为网页名称；POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO</li>
<li>不允许任何魔数出现在代码中（深有体会）</li>
<li>long 或 Long 赋初始值时，使用大写的 L，以免与1混淆</li>
<li>不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护</li>
<li>注意常量的复用层次，根据不同的复用层次来决定常量放置的位置</li>
<li>如果变量值仅在一个固定范围内变化用 enum 类型来定义（例如一年有几个季节）</li>
<li>if/for/while/switch/do 等保留字与括号之间都必须加空格</li>
<li>任何二目、三目运算符的左右两边都需要加一个空格</li>
<li>采用 4 个空格缩进，禁止使用 tab 字符</li>
<li>注释的双斜线与注释内容之间有且仅有一个空格</li>
<li>IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，<br>不要使用 Windows 格式</li>
<li>避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成<br>本，直接用类名来访问即可</li>
<li>所有的覆写方法，必须加@Override 注解</li>
<li>避免使用可变参数编程</li>
<li>不能使用过时的类或方法</li>
<li>Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用<br>equals（例如：”hello”.equals(object) 而不是 object.equals(“hello”)）</li>
<li>所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较</li>
<li><strong>所有的 POJO 类属性必须使用包装数据类型</strong></li>
<li><strong>RPC 方法的返回值和参数必须使用包装数据类型</strong></li>
<li>所有的局部变量使用基本数据类型</li>
<li>定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值</li>
<li>在进行序列化和反序列化时不要轻易修改serialVersionUID 的值</li>
<li>POJO 类必须写 toString 方法。使用 IDE 中的工具：source&gt; generate toString<br>时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString</li>
<li>使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无<br>内容的检查，否则会有抛 IndexOutOfBoundsException 的风险</li>
<li>setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在<br>getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度</li>
<li>循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展（有利于提高效率）</li>
<li>慎用 Object 的 clone 方法来拷贝对象</li>
<li>类成员与方法访问控制从严</li>
<li>要注意对 ArrayList 的 subList 的操作，以及 subList 不可强转成 ArrayList</li>
<li>不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator<br>方式，如果并发操作，需要对 Iterator 对象加锁</li>
<li>使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历</li>
<li>获取单例对象需要保证线程安全，其中的方法也要保证线程安全</li>
<li>创建线程或线程池时请指定有意义的线程名称，方便出错时回溯</li>
<li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</li>
<li>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能<br>锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁</li>
<li>ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static<br>修饰</li>
<li>在 if/else/for/while/do 语句中必须使用大括号</li>
<li>在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程<br>序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使空代码 </li>
<li>在高并发场景中，避免使用”等于”判断作为中断或退出的条件（因为等值判断可能被击穿）</li>
<li>避免采用取反逻辑运算符</li>
<li>要注意参数校验的场景（内部校验和外部校验）</li>
<li>类、类属性、类方法的注释必须使用 Javadoc 规范，使用/<em>*内容</em>/格式，不得使用// xxx 方式</li>
<li>所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、<br>异常说明外，还必须指出该方法做什么事情，实现什么功能</li>
<li>所有的类都必须添加创建者和创建日期</li>
<li>所有的枚举类型字段必须要有注释，说明每个数据项的用途</li>
<li>代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑<br>等的修改</li>
<li>待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）</li>
<li>错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）</li>
<li>Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过<br>catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等</li>
<li>异常不要用来做流程控制，条件控制</li>
<li>catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。<br>对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理</li>
<li>异常捕获后必须要进行处理</li>
<li>有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回<br>滚事务</li>
<li>finally 块必须对资源对象、流对象进行关闭</li>
<li>捕获异常与抛异常，必须是完全匹配</li>
<li>防止 NullPointerException 是程序员的基本修养，要注意 NullPointerException 发生的场景</li>
<li>避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则</li>
<li>应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架<br>SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一</li>
<li>日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点</li>
<li>注意日志文件的命名方式</li>
<li>对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方<br>式，以免造成资源的浪费</li>
<li>后台输送给页面的变量必须加$!{var}——中间的感叹号</li>
<li>注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够<br>取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法</li>
<li>获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime()</li>
<li>不要在视图模板中加入任何复杂的逻辑</li>
<li>任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存</li>
<li>隶属于用户个人的页面或者功能必须进行权限控制校验</li>
<li>用户敏感数据禁止直接展示，必须对展示数据进行脱敏</li>
<li>严禁SQL 注入</li>
<li>用户请求传入的任何参数必须做有效性验证</li>
<li>表单、AJAX 提交必须执行 CSRF 安全过滤</li>
<li>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint<br>（ 1 表示是，0 表示否）</li>
<li>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只<br>出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑</li>
<li>表名不使用复数名词</li>
<li>禁用MYSQL官方保留字</li>
<li>小数类型为 decimal，禁止使用 float 和 double</li>
<li>表必备三字段：id, gmt_create, gmt_modified</li>
<li>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表</li>
<li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引</li>
<li>超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，<br>保证被关联的字段需要有索引</li>
<li>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决</li>
<li>利用延迟关联或者子查询优化超多分页场景</li>
<li>不要使用 count(列名)或 count(常量)来替代 count(*)</li>
<li>当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为<br>NULL，因此使用 sum()时需注意 NPE 问题</li>
<li>NULL 与任何值的直接比较都为 NULL</li>
<li>在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句</li>
<li>不得使用外键与级联，一切外键概念必须在应用层解决</li>
<li>数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认<br>无误才能执行更新语句</li>
<li>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明</li>
<li>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出</li>
<li>更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间</li>
<li>@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需<br>要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等</li>
</ul>
]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>阿里巴巴Java 约规手册</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算之两数相除 </title>
    <url>/2019/12/24/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%20/</url>
    <content><![CDATA[<p>leetcode 上第29题两数相除，刚开始的时候我的思路是通过while 循环和加减法来实现，后来在编码实现的时候对于除数和被除数的符号相同时可以得出正确答案，但是符号不同时就会出现错误。在评论区看一些大佬的解题思路让我受益匪浅，其中我认为较好的一种思路是使用位运算，用左移去减，因为整数边界问题比较麻烦，所以改用负数计算。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ^ 是异或运算符，相同为0 不同为1</span></span><br><span class="line">        <span class="keyword">boolean</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将整数全部转化为负数再进行运算</span></span><br><span class="line">        <span class="keyword">if</span>(dividend&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(divisor&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        	divisor = -divisor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(dividend &lt;= divisor) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp_result = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> temp_divisor = divisor;</span><br><span class="line">            <span class="comment">// // 左移一位相当于乘以二，右移一位相当于除以二</span></span><br><span class="line">            <span class="keyword">while</span>(dividend &lt;= (temp_divisor &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp_divisor &lt;= (Integer.MIN_VALUE &gt;&gt; <span class="number">1</span>))<span class="keyword">break</span>;</span><br><span class="line">                temp_result = temp_result &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                temp_divisor = temp_divisor &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dividend = dividend - temp_divisor;</span><br><span class="line">            result += temp_result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!sign) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result &lt;= Integer.MIN_VALUE) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            result = - result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于我对java 中位运算符不是很了解，就去查了一下资料，以下是关于<strong>java 中^、&amp;、| 和位运算符的含义：</strong></p>
<ul>
<li><p><strong>^（异或运算符）</strong><br>  ^ 是针对二进制的二目运算符。运算规则：两个二进制数值如果在同一位上相同，则结果中该位为0，否则为1，比如1011 ^ 0010 = 1001。</p>
</li>
<li><p><strong><em>|（或运算符）</em></strong><br> | 是针对二进制的二目运算符。运算规则：两个二进制数值如果在同一位上至少有一个1，则结果中该位为1，否则为0，比如1011 | 0010 = 1011。</p>
</li>
<li><p><strong><em>&amp;（与运算符）</em></strong><br> &amp;是是针对二进制的二目运算符。需要注意的是&amp;&amp;是java中判断条件之间表示“和”的标识符，&amp;是一个二目运算符，两个二进制数值如果在同一位上都是1，则结果中该位为1，否则为0，可以认为两个都是true(1)，结果也为true(1)，比如1011 &amp; 0110 = 0010。</p>
</li>
<li><p><strong>位运算符</strong></p>
<ul>
<li><em>&gt;&gt;x（常数）: 向右移动x位（顶点在哪个方向就往哪个方向移动），如果该数是正数，则高位（最左边）补x个0，如果是负数，则最高位补x个1。*</em><ul>
<li>*&lt;&lt;x（常数）: 向左移动x位（顶点在哪个方向就往哪个方向移动），无论正负数低位（最右边）都补x个0**</li>
<li>*&lt;&lt;&lt;: 无该表示方式 **</li>
<li><em>&gt;&gt;&gt;x(常数): 表示无符号右移x位，所谓无符号是与&gt;&gt;x对比，该操作在移动后，无论正负数高位（最左边）都补0。*</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>简单来说，左移一位相当于乘以x，右移一位相当于除以x.</strong></p>
]]></content>
  </entry>
  <entry>
    <title>二叉树的定义及遍历</title>
    <url>/2019/12/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>最近在刷算法题的过程中发现以前学过的一些数据结构方面的知识有些遗忘了，就开始复习数据结构。</p>
<p>在计算机科学中，二叉树（binaryTree）是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p>
<p>以下是关于二叉树的创建及其递归和非递归的三种遍历方式，在刷算法题的过程中发现二叉树可以运用在多种场景下，在运用得当的情况下可以极大提升程序的效率，但万丈高楼平地起，只有对二叉树基础定义、实现及遍历足够了解，才能将其运用得当。</p>
<ul>
<li>二叉树的结点定义类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		 Node leftChild;</span><br><span class="line">		 Node rightChild;</span><br><span class="line">		 <span class="keyword">int</span> data;</span><br><span class="line">		 </span><br><span class="line">		 Node(<span class="keyword">int</span> data) &#123;</span><br><span class="line">			 leftChild = <span class="keyword">null</span>;</span><br><span class="line">			 rightChild = <span class="keyword">null</span>;</span><br><span class="line">			 <span class="keyword">this</span>.data = data;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<pre><code>由于二叉树具有天然的递归结构，因此在二叉树的创建及遍历过程中使用递归是不错的方法。</code></pre><ul>
<li>二叉树的创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建二叉树</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		 nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		 <span class="comment">// 将数组中的值依次转化为二叉树的结点</span></span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">			 nodeList.add(<span class="keyword">new</span> Node(array[i]));</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length/<span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			 nodeList.get(i).leftChild = nodeList.get(<span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">			 nodeList.get(i).rightChild = nodeList.get(<span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">int</span> lastIndex = array.length/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">		 nodeList.get(lastIndex).leftChild = nodeList.get(<span class="number">2</span> * lastIndex + <span class="number">1</span>);</span><br><span class="line">		 <span class="comment">// 判断是否有右节点</span></span><br><span class="line">		 <span class="keyword">if</span>(array.length % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">			 nodeList.get(lastIndex).rightChild = nodeList.get(<span class="number">2</span> * lastIndex + <span class="number">2</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>二叉树的遍历方式分为先序、中序及后续遍历，每种遍历方式都可以通过递归和非递归两种方式完成</em>。</strong></p>
<pre><code>递归方式的先序、中序及后续遍历</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">		 preOrderTraverse(node.leftChild);</span><br><span class="line">		 preOrderTraverse(node.rightChild);</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 中序遍历</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 inOrderTraverse(node.leftChild);</span><br><span class="line">		 System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">		 inOrderTraverse(node.rightChild);</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 后序 遍历</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 afterOrderTraverse(node.leftChild);</span><br><span class="line">		 afterOrderTraverse(node.rightChild);</span><br><span class="line">		 System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<pre><code>非递归方式的先序、中序及后续遍历</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归前序遍历</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> ;</span><br><span class="line">		 &#125;</span><br><span class="line">		 Node temp = node;</span><br><span class="line">		 Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		 <span class="comment">// 根节点入栈</span></span><br><span class="line">		 s.push(temp);</span><br><span class="line">		 <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">			 <span class="comment">// 1. 访问根节点</span></span><br><span class="line">			 Node pop = s.pop();</span><br><span class="line">			 System.out.print(pop.data + <span class="string">" "</span>);</span><br><span class="line">			 <span class="comment">// 2. 若根节点存在右孩子结点，将其入栈</span></span><br><span class="line">			 <span class="keyword">if</span>(pop.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">				 s.push(pop.rightChild);</span><br><span class="line">			 &#125;</span><br><span class="line">			<span class="comment">// 3. 若根节点存在左孩子结点，将其入栈</span></span><br><span class="line">			 <span class="keyword">if</span>(pop.leftChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">				 s.push(pop.leftChild);</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 非递归中序遍历</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> ;</span><br><span class="line">		 &#125;</span><br><span class="line">		 Node temp = node;</span><br><span class="line">		 Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		 <span class="keyword">while</span>(temp != <span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">			 <span class="comment">// 1. 将根节点入栈</span></span><br><span class="line">			 <span class="comment">// 2. 将所有左孩子入栈</span></span><br><span class="line">			 <span class="keyword">while</span>(temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">				 s.push(temp);</span><br><span class="line">				 temp = temp.leftChild;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="comment">// 3. 访问栈顶元素</span></span><br><span class="line">			 temp = s.pop();</span><br><span class="line">			 System.out.print(temp.data + <span class="string">" "</span>);</span><br><span class="line">			 <span class="comment">// 4. 若栈顶元素存在右孩子结点，则将右孩子赋值给temp,也就是将右孩子入栈</span></span><br><span class="line">			 <span class="keyword">if</span>(temp.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">				 temp = temp.rightChild;</span><br><span class="line">			 &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				 temp = <span class="keyword">null</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 非递归后序遍历</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> ;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="comment">// 当前结点</span></span><br><span class="line">		 Node temp = node;</span><br><span class="line">		 <span class="comment">// 上一次访问的结点;</span></span><br><span class="line">		 Node prev = <span class="keyword">null</span>;</span><br><span class="line">		 Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		 <span class="keyword">while</span>(temp != <span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">			 <span class="comment">// 1. 将根结点及其左孩子入栈</span></span><br><span class="line">			 <span class="keyword">while</span>(temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">				 s.push(temp);</span><br><span class="line">				 temp = temp.leftChild;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">if</span>(!s.isEmpty()) &#123;</span><br><span class="line">				 <span class="comment">// 2. 获取栈顶元素值</span></span><br><span class="line">				 temp = s.peek();</span><br><span class="line">				 <span class="comment">// 3. 没有右孩子，或者右孩子已经被访问过</span></span><br><span class="line">				 <span class="keyword">if</span>(temp.rightChild == <span class="keyword">null</span> || temp.rightChild == prev) &#123;</span><br><span class="line">					 temp = s.pop();</span><br><span class="line">					 System.out.print(temp.data + <span class="string">" "</span>);</span><br><span class="line">					 <span class="comment">// 标记上一次访问的结点</span></span><br><span class="line">					 prev = temp;</span><br><span class="line">					 temp = <span class="keyword">null</span>;</span><br><span class="line">				 &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					 <span class="comment">// 存在没有被访问的右孩子</span></span><br><span class="line">					 temp = temp.rightChild;</span><br><span class="line">				 &#125;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>动态规划算法</title>
    <url>/2019/12/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。</p>
<p>利用动态规划原理解决问题的大致步骤为：</p>
<ol>
<li>确认原问题和子问题</li>
<li>确认状态</li>
<li>确认边界状态的值</li>
<li>确定状态转移方程</li>
</ol>
<p>以下是我在leetcode上刷的关于动态规划的几道习题的代码和思路</p>
<ul>
<li><strong>爬楼梯—-leetcode70</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 爬楼梯----leetcode70</span></span><br><span class="line"><span class="comment">	 * 动态规划原理</span></span><br><span class="line"><span class="comment">	 * 	1. 确认原问题和子问题</span></span><br><span class="line"><span class="comment">	 * 		原问题是求 n 阶台阶所有走法的数量，子问题是求 1、2、3....n-1</span></span><br><span class="line"><span class="comment">	 * 		阶台阶的走法</span></span><br><span class="line"><span class="comment">	 * 	2. 确认状态</span></span><br><span class="line"><span class="comment">	 * 		本题的动态规划状态单一，第i个状态即为i阶台阶的所有走法数量</span></span><br><span class="line"><span class="comment">	 * 	3. 确认边界状态的值</span></span><br><span class="line"><span class="comment">	 * 		边界状态为1阶台阶和2阶台阶的走法，1阶台阶有1种走法，2阶台阶有2种走法，即dp[0]=1,dp[1]=2</span></span><br><span class="line"><span class="comment">	 * 	4. 确定状态转移方程</span></span><br><span class="line"><span class="comment">	 * 		将求第i 个状态的值转化为求第i-1 个状态的值和第i-2 个状态的值，</span></span><br><span class="line"><span class="comment">	 * 		动态规划转换方程为 ：dp[i]=dp[i-1]+dp[i-2]</span></span><br><span class="line"><span class="comment">	 **/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">			dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>打家劫舍—leetcode198</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 打家劫舍---leetcode198</span></span><br><span class="line"><span class="comment">	 * 动态规划原理</span></span><br><span class="line"><span class="comment">	 * 	1. 确认原问题和子问题</span></span><br><span class="line"><span class="comment">	 * 		原问题为n 个房间的最优解，子问题为求前1个房间、前两个房间、前n-1个房间的最优解</span></span><br><span class="line"><span class="comment">	 * 	2. 确认状态</span></span><br><span class="line"><span class="comment">	 * 		第i 个状态即为前i 能够获得的最大财宝（最优解）个房间</span></span><br><span class="line"><span class="comment">	 * 	3. 确认边界状态的值</span></span><br><span class="line"><span class="comment">	 * 		前1个房间的最优解为第1个房间的财宝</span></span><br><span class="line"><span class="comment">	 * 		前2个房间的最优解为第1、2个房间中财宝的较大值</span></span><br><span class="line"><span class="comment">	 * 	4. 确定状态转移方程</span></span><br><span class="line"><span class="comment">	 * 		a. 选择第i 个房间：第i 个房间 + 前i-2 个房间的最优解</span></span><br><span class="line"><span class="comment">	 * 		b. 选择第i-1 个房间：前i-1 个房间的最优解</span></span><br><span class="line"><span class="comment">	 * 		动态规划转移方程：</span></span><br><span class="line"><span class="comment">	 * 			dp[i] = max(dp[i-1], dp[i-2] + nums[i])</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">		dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">		dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>最大子序和—leetcode53</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 最大子序和---leetcode53</span></span><br><span class="line"><span class="comment">	 * 动态规划原理</span></span><br><span class="line"><span class="comment">	 * 	1. 确认原问题和子问题</span></span><br><span class="line"><span class="comment">	 * 		原问题为在数组中找到一个具有最大和的连续子数组，</span></span><br><span class="line"><span class="comment">	 * 		子问题为找到以原数组中每个元素结尾的子数组的最优解</span></span><br><span class="line"><span class="comment">	 * 	2. 确认状态</span></span><br><span class="line"><span class="comment">	 * 		第i 个状态即为以第i 个数字结尾的最优解</span></span><br><span class="line"><span class="comment">	 *	3. 确认边界状态的值</span></span><br><span class="line"><span class="comment">	 *		以第一个数字结尾的最大字段和dp[0]=nums[0]</span></span><br><span class="line"><span class="comment">	 *	4. 确定状态转移方程</span></span><br><span class="line"><span class="comment">	 *		a. 当dp[i-1]&gt;0：dp[i] = dp[i-1]+nums[i]</span></span><br><span class="line"><span class="comment">	 *		b. 当dp[i-1]&lt;0：dp[i] = nums[i];</span></span><br><span class="line"><span class="comment">	 *		dp[i] = max(dp[i-1]+nums[i], nums[i])</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">		dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">		dp[<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>]+nums[<span class="number">1</span>], nums[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			dp[i] = Math.max(dp[i-<span class="number">1</span>]+nums[i], nums[i]);</span><br><span class="line">			<span class="keyword">if</span>(dp[i] &gt; max) &#123;</span><br><span class="line">				max = dp[i];</span><br><span class="line">			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>零钱兑换—leetcode322</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 零钱兑换---leetcode322</span></span><br><span class="line"><span class="comment">	 * 动态规划</span></span><br><span class="line"><span class="comment">	 * 		dp[i]数组用来表示0到amount数额之间的每个值所需的最小硬币数量</span></span><br><span class="line"><span class="comment">	 * 		因为数组下标是从0开始的，因此dp数组的长度应该为amount+1</span></span><br><span class="line"><span class="comment">	 * 		设 coins为[1, 2, 5],amount=11,则dp[0]=0, dp[1]=1,dp[2]=1,dp[3]=2,dp[4]=2,</span></span><br><span class="line"><span class="comment">	 * 		dp[5]=1, dp[6]=2, dp[7]=2, dp[8]=3, dp[9]=3, dp[10]=2, dp[11]=3,</span></span><br><span class="line"><span class="comment">	 * 		因此当amount为11时的结果为3</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(coins == <span class="keyword">null</span> || coins.length == <span class="number">0</span> || amount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">			dp[i] = amount+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(coins[j] &lt;= i) &#123;</span><br><span class="line">					dp[i] = Math.min(dp[i], dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>三角形最小路径和—leetcode120（经典动态规划练习题）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 三角形最小路径和---leetcode120（经典动态规划练习题）</span></span><br><span class="line"><span class="comment">	 * 	算法思路：</span></span><br><span class="line"><span class="comment">	 * 		1.设置一个二维数组，最优值三角形dp[][]，并初始化数组元素为0，</span></span><br><span class="line"><span class="comment">	 * 		  dp[i][j]代表了数组三角形第i行， 第j列的最优解（从底往上推）</span></span><br><span class="line"><span class="comment">	 * 		2.从三角形的地面向三角形上方进行动态规划</span></span><br><span class="line"><span class="comment">	 * 			a. 动态规划边界条件：地面上的最优解的即为数字三角形的最后一层</span></span><br><span class="line"><span class="comment">	 * 			b. 利用i循环，从倒数第二层递推至正数第一层，对于每层的各列，进行动态规划递推：</span></span><br><span class="line"><span class="comment">	 * 			        第i行， 第j列的最优解为dp[i][j]，可到达(i, j)的两个位置的最优解为</span></span><br><span class="line"><span class="comment">	 * 			   dp[i+1][j]、dp[i+1]dp[j+1]</span></span><br><span class="line"><span class="comment">	 * 			       状态转换方程为：dp[i][j]=min(dp[i+1][j], dp[i+1][j+1])+triangle[i][j]</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(triangle == <span class="keyword">null</span> || triangle.size() == <span class="number">0</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.size()][triangle.size()];</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			 List&lt;Integer&gt; list = triangle.get(i);</span><br><span class="line">			 <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">				 dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j], dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+list.get(j);</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>最长上升子序列—leetcode300</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	  * 最长上升子序列---leetcode300</span></span><br><span class="line"><span class="comment">	  * 	动态规划</span></span><br><span class="line"><span class="comment">	  * 		若第i个状态dp[i]代表以第i个元素结尾的最大上升子序列的长度：</span></span><br><span class="line"><span class="comment">	  * 		dp[i-1]代表以第i-1个元素结尾的最大上升子序列的长度</span></span><br><span class="line"><span class="comment">	  * */</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">		 dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			 <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">			 <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">				 <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">					 max = Math.max(max, dp[j]);</span><br><span class="line">				 &#125;</span><br><span class="line">			 &#125;</span><br><span class="line">			 dp[i] = max + <span class="number">1</span>;</span><br><span class="line">			 maxlen = Math.max(maxlen, dp[i]);</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> maxlen;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>最小路径和—leetCode64</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	  * 最小路径和---leetCode64</span></span><br><span class="line"><span class="comment">	  * 	和三角形的最小路径和相似（但是要注意边界条件的判断）</span></span><br><span class="line"><span class="comment">	  * */</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length+<span class="number">1</span>][grid[<span class="number">0</span>].length+<span class="number">1</span>];</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i = grid.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			 <span class="keyword">for</span>(<span class="keyword">int</span> j = grid[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="keyword">if</span>(i == grid.length - <span class="number">1</span> &amp;&amp; j != grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">	                dp[i][j] = grid[i][j] +  dp[i][j + <span class="number">1</span>];</span><br><span class="line">	            <span class="keyword">else</span> <span class="keyword">if</span>(j == grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">	                dp[i][j] = grid[i][j] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">	            <span class="keyword">else</span> <span class="keyword">if</span>(j != grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">	                dp[i][j] = grid[i][j] + Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">	            <span class="keyword">else</span></span><br><span class="line">	                dp[i][j] = grid[i][j];</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>java设计模式之单例模式</title>
    <url>/2019/12/24/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式（Singleton Pattern）属于创建型模式，它提供了一种创建对象较好的方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时保证只有单个对象被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>注意：</p>
<ol>
<li><p>一个类只能有一个实例</p>
</li>
<li><p>单例类必须自己创建自己的唯一实例。</p>
</li>
<li><p>单例类必须给所有其他对象提供这一实例。</p>
<p>单例模式的目的：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
<p>使用场景：向想确保任何情况下都只有一个实例（线程池、数据库连接池等）</p>
<p>优点：在内存里只有一个实例，减少了内存开销、可以避免对资源的多重占用、设置全局            访问点，严格控制访问</p>
<p>缺点：没有接口、扩展困难</p>
<p>重点：私有构造器、线程安全、延迟加载、序列化和反序列化安全、反射</p>
<p>相关设计模式：单例模式和工厂模式、单例模式和享元模式</p>
</li>
</ol>
<p><strong>单例模式的集中实现方式：</strong></p>
<ul>
<li>懒汉式（线程不安全）<br>懒汉式单例模式，顾名思义，这种单例模式很懒，在初始化的时候不创建，而是做一个延迟加载。这种实现方式最大的问题是在多线程的场景下不安全，没有加 synchronized 锁 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lazySingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">			lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> lazySingleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DoubleCheck双重检查实现懒汉式（线程安全）<br>上述延迟加载的模式在多线程的情况下是不安全的，为了解决多线程问题，可以采用DoubleCheck双重检查实现懒汉式。这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是效率很低。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckSingleton lazyDoubleCheckSingleton = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lazyDoubleCheckSingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (LazyDoubleCheckSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(lazyDoubleCheckSingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">					lazyDoubleCheckSingleton = <span class="keyword">new</span> LazyDoubleCheckSingleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> lazyDoubleCheckSingleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态内部类（线程安全）<br>基于类初始化的延迟加载，这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">// InnerClass类的对象的初始化锁被哪个线程拿到，那个线程负责实例化对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassSingleton staticInnerClassSingleton = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> InnerClass.staticInnerClassSingleton;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>饿汉式（线程安全）<br>在类加载的时候就完成类的实例化。这种方式比较常用，但容易产生垃圾对象。它没有加锁，执行效率会提高，但是类加载时就初始化，浪费内存。它基于 classloader 机制避免了多线程的同步问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton hungrySingleton;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hungrySingleton;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>序列化破坏单例模式原理解析及解决方案（以饿汉式为例）<br>在序列化和反序列化之后拿到的不是同一个对象。这是因为ObjectInputStream 对象的readObject()方法调用了readObject0()方法，而当ObjectInputStream 读入的是对象时，readObject0()方法中的 readOrdinaryObject(unshared)方法会调用isInstantiable()方法，isInstantiable()方法在类运行时被实例化时会返回true,然后会调用newInstance()方法，这样就通过反射又创建了一个对象，所以在序列化和反序列化之后拿到的不是同一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singleton_file"</span>));</span><br><span class="line">oos.writeObject(instance);</span><br><span class="line"></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"singleton_file"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">HungrySingleton newInstance = (HungrySingleton)ois.readObject();</span><br><span class="line"></span><br><span class="line">System.out.println(instance);</span><br><span class="line">System.out.println(newInstance);</span><br><span class="line"><span class="comment">// 结果为 false ,说明两者不是同一个对象，这就违背了单例设计模式</span></span><br><span class="line">System.out.println(instance == newInstance);</span><br><span class="line">oos.close();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure>
<p>解决方案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton hungrySingleton;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hungrySingleton;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hungrySingleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>反射攻击解决方案及原理分析（以饿汉式为例）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class objectClass = HungrySingleton<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();</span><br><span class="line">System.out.println(instance);</span><br><span class="line">System.out.println(newInstance);</span><br><span class="line"><span class="comment">// 结果为 false ,说明两者不是同一个对象，这就违背了单例设计模式</span></span><br><span class="line">System.out.println(instance == newInstance);</span><br></pre></td></tr></table></figure>
<p>解决方案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton hungrySingleton;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(hungrySingleton != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射调用"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hungrySingleton;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Enum枚举单例（线程安全）<br>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumInstance &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">	<span class="keyword">private</span> Object date;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> date;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Object date)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.date = date;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>容器单例模式（线程安全问题取决于具体的实现）<br>容器单例的思路是这样的，维护一个Map，把单例的实例都存放进该Map中，用的时候只从该Map中取，试图实现单例；但这种思路有局限性，Map中存的单例对象是可以被更新掉的，如果两次取的间隔，发生了单例对象的更新，就会取到2个不同的对象，破坏了单例性；</p>
<p> 应用场景：如果程序中单例类很多，可以考虑用一个容器管理起来；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; singletonMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(); </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putInstance</span><span class="params">(String key, Object instance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!singletonMap.containsKey(key)) &#123;</span><br><span class="line">				singletonMap.put(key, instance);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> singletonMap.get(key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ThreadLocal 线程“单例模式”<br>不是传统意义中的单例模式，不同线程之间拿到的对象可能不同，但是每个线程中对象都是单例的</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>java设计模式之代理模式</title>
    <url>/2019/12/24/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>代理模式（Proxy Pattern）为其他对象（类）提供一种代理，以控制对这个对象（类）的访问。代理对象在客户端和目标对象之间起到中介的作用。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<p>当直接访问对象会遇到一些问题时，例如：有些对象由于一些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），这时直接访问就不是一种好的选择。</p>
<p>代理的思想在实际中也有很多的运用，例如：Windows快捷方式，Spring AOP的实现。</p>
<p>代理模式的应用场景：保护目标对象（控制对目标对象的访问）、增强目标对象</p>
<p>代理模式的优点：</p>
<ul>
<li>代理模式能将代理对象与真实被调用的目标对象分离</li>
<li>一定程度上降低了系统的耦合度，扩展性好</li>
<li>保护目标对象</li>
<li>增强目标对象</li>
</ul>
<p>代理模式的缺点：</p>
<ul>
<li>代理模式会造成系统设计中类的数目增加</li>
<li>在客户端和目标对象间增加一个代理对象，会造成请求处理速度变慢</li>
<li>增加系统的复杂度</li>
</ul>
<p>相关设计模式：装饰者模式、适配器模式</p>
<p>注意：</p>
<ul>
<li>适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口</li>
<li>装饰器模式为了增强功能，而代理模式是为了加以控制</li>
</ul>
<p>代理分为静态代理和动态代理，而动态代理又有两种实现方式：</p>
<ul>
<li>JDK动态代理（无法代理类，只能代理接口）</li>
<li>CGLib代理（通过继承，使用时要注意final修饰符）</li>
</ul>
<p>接下来，我用一个简易下单的方式对代理模式进行实现</p>
<ul>
<li>静态代理<br>步骤一：创建一个实体对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object orderInfo;</span><br><span class="line">	<span class="keyword">private</span> Integer userId;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getOrderInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> orderInfo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderInfo</span><span class="params">(Object orderInfo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.orderInfo = orderInfo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userId = userId;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 步骤二：创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOrderService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤三：创建接口的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">IOrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> IOrderDao orderDao;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		orderDao = <span class="keyword">new</span> OrderDaoImpl();</span><br><span class="line">		System.out.println(<span class="string">"service层调用dao层方法添加订单"</span>);</span><br><span class="line">		<span class="keyword">return</span> orderDao.insert(order);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤四：创建dao层接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOrderDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤五：创建dao层接口的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title">IOrderDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Dao层添加Order成功"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK静态代理实现之创建静态代理类</strong></p>
<ul>
<li>java.lang.reflect.Proxy:生成动态代理类和对象；</li>
<li>java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceStaticProxy</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> IOrderService iOrderService;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对IOrderService接口中的方法进行增强</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		beforeMethod(order);</span><br><span class="line">		iOrderService = <span class="keyword">new</span> OrderServiceImpl();</span><br><span class="line">		afterMethod();</span><br><span class="line">		<span class="keyword">int</span> result = iOrderService.saveOrder(order);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态代理 before code"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态代理 after code"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK动态代理实现之创建动态代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceDynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderServiceDynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Class&lt;? extends Object&gt; cls = target.getClass();</span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(cls.getClassLoader(), cls.getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		Object argObject = args[<span class="number">0</span>];</span><br><span class="line">		beforeMethod(argObject);</span><br><span class="line">		Object object = method.invoke(target, args);</span><br><span class="line">		afterMethod();</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"动态代理 before code"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"动态代理 after code"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Cglib 动态代理</strong><br>Cglib 动态代理是针对代理的类, 动态生成一个子类, 然后子类覆盖代理类中的方法, 如果是private或是final类修饰的方法,则不会被重写。</p>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。两者没有什么本质的区别。</p>
]]></content>
  </entry>
  <entry>
    <title>源码分析之HashMapde的底层实现</title>
    <url>/2019/12/24/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHashMapde%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>引言</title>
    <url>/2019/12/24/%E5%BC%95%E8%A8%80/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>   明天是学校正式开学的一天，我也要迎来了自己的大三生活。我学的专业是计算机科学与技术，从大一下学期接触到java时，我就对其产生了很大的兴趣，然后一直在学习关于java方面的知识。注册CSDN已经很长时间了，但是这是第一次写博客，以前在学习的时候也想着写博客，但是那时自己的整体学习路线还没有梳理清楚，写的博客也类似于笔记，并没有太大的意义。目前在经过一年半的学习后，我对J2EE开发的大体架构和学习路线也有了更深的认识，因此开始写博客来对所学的知识进行梳理与总结。<br>    在大一下的学期，我重点学习了java基础知识，比如：标识符和数据类型、表达式和流程控制语句、数组、向量和字符串、对象和类、异常、IO。在这个阶段我并没有对java的多线程、高并发、网络功能以及最底层的java虚拟机、代码安全、垃圾收集机制、集合框架的源码进行深入的了解，就进入了J2EE的学习。<br>    在大一下的暑假，我学习了html、css、js、jsp、Bootstrap、jQuery、JDBC、mysql、Servlet、tomcat、ajax、xml、json、拦截器、过滤器等基础Web开发知识。然后用一个月的时间学习了SpringMVC、Spring、Mybatis三个框架，并将其整合做了个小型的网站。在整合SSM框架时，遇到了各种各样因为jar包冲突而引起的问题，因此我开始学习maven（后来又学了gradle进行构建，个人感觉gradle好用一些）来构建代码和项目管理。当时实验室的学长告诉我们最好要拥有开发自己的技术博客，这样既可以对平时的学习进行总结，也可以在面试中加分。所有我就开始开发属于自己的博客网站。因为是第一次写一个完整的网站，所以在开发过程中遇到各种问题。因为要实现网站的搜索功能，我开始学习全文检索（Lucene、ElasticSearch）。在这个过程中我用了大概三个月的时间。到此，我的大一生涯也结束了。<br>    在大二上的学期开设了数据结构与算法分析课程，数据结构和算法对于从事计算机的人的重要性众所周知。因此，我在这上面也投入了很多精力。对着微服务的概念越来越被认可，同时自己也觉得Spring框架的配置十分繁琐，于是就去了解了关于SpringBoot的知识。<br>    在大二下的学期，我开始了解关于缓存、高并发、分布式的相关知识。关于缓存，我着重学习了redis，在这过程中对于缓存设计的目的、缓存的持久化、缓存复制的原理、缓存的更新、穿透和无底洞、redis的高可用以及redis集群等有了一定的认识。在高并发方面，我写了一个秒杀系统，使用redis作为缓存，RabbitMQ作为消息队列以及页面静态化来减小对数据库访问的压力，提高系统的QPS。关于分布式，我了解了分布式的基本概念以及分布式系统解决的问题以及在设计分布式系统中应该注意的问题。但是我对于分布式的理解还是很浅，需要更加深入的去了解。<br>    马上就要步入大三上，我学习的方向是深入多线程、了解java最底层的知识（java虚拟机、CG等）、MySQL调优、学习一些基本的设计模式、看一些源码（Spring、Hashmap等）从而了解那些是如何写代码的。</p>
]]></content>
  </entry>
  <entry>
    <title>网络协议----一次网购下单的过程</title>
    <url>/2019/12/24/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE----%E4%B8%80%E6%AC%A1%E7%BD%91%E8%B4%AD%E4%B8%8B%E5%8D%95%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在极客时间刘超先生的趣谈网络协议的专栏上看到了一篇关于通过一次网购下单的过程来看看互联网世界的运行过程中，都使用了哪些网络协议的文章，这让我受益匪浅。因此，我打算写下这篇博客来记录看完以及结合一些其他的资料后的收获。<br> 当我们在网上购物时，现在浏览器里输入<a href="http://www.taobao.com，这是一个URL。而浏览器只知道这是一个URL，而无法找到具体服务器所在的位置，因此无法访问到。于是浏览器打开地址簿进行查找（一般使用DNS域名解析来查找）。" target="_blank" rel="noopener">www.taobao.com，这是一个URL。而浏览器只知道这是一个URL，而无法找到具体服务器所在的位置，因此无法访问到。于是浏览器打开地址簿进行查找（一般使用DNS域名解析来查找）。</a></p>
<ul>
<li>DNS域名解析过程<br> <img src="https://img-blog.csdnimg.cn/20190905103545669.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="DNS域名解析"><br>第一步，浏览器会检查缓存中有没有这个域名对应的解析过的IP<br>第二步，若浏览器没有，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果<br>第三步，使用本地区的域名服务器（LDNS）进行域名的解析工作<br>第四步，若LDNS仍然没有命中，就直接到Root Server域名服务器请求解析<br>第五步，Root Server 会返回LDNS一个所查询域的主域名服务器（gTLD Server）地址。<br>第六步，LDNS向上一步返回的gTLD服务器发送请求<br>第七布，接受请求的gTLD 服务器查找并返回此域名对应的 Name Server 域名服务器的地址，这个Name Server 通常就是你注册的域名服务器<br>第八步，Name Server 域名服务器会查询存储的域名和 IP 的映射关系表，将 IP 连同一个 TTL 值返回个DNS Server 域名服务器<br>第九步，返回该域名对应的 IP 和 TTL 值，LDNS 会缓存这个域名和 IP 的对应关系，缓存的时间有 TTL 值控制<br>第十步，将解析的结果返回，用户根据 TTL 值缓存在本地系统缓存中</li>
</ul>
<p>在找到 URL 对应的的 IP 地址后，浏览器就开始打包它的请求。对于一般的请求，使用 HTTP 协议就可以了，但是涉及到需要加密传输的数据（例如支付密码等）就会使用HTTPS 协议。但无论是哪一种协议，都要写上“买什么，买多少”。<br><img src="https://img-blog.csdnimg.cn/20190905105355481.png" alt="在这里插入图片描述"><br>DNS、HTTP、HTTPS 都属于应用层协议。经过应用层封装后，浏览器会将应用层的数据包交给下一层去完成，通过Socket 网络编程来实现。下一层是传输层。传输层有两种协议，一种是无连接的协议UDP，一种是面向连接的协议TCP。对于支付来讲，往往使用TCP协议。所谓的面向连接就是，TCP会保证这个包能够到达目的地。如果不能到达，就会重新发送，直至到达。</p>
<p>TCP 协议里面有两个端口—浏览器监听的端口以及电商服务器监听的端口。<br><img src="https://img-blog.csdnimg.cn/20190905105724176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>传输层封装完毕后，浏览器会将包交给操作系统的网络层。网络层的协议是IP协议。在IP协议里面会有源IP地址，即浏览器所在机器的IP地址和目标IP地址，也即电商网站所在服务器的IP地址。<br><img src="https://img-blog.csdnimg.cn/2019090510575487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时既然知道了目标机器的 IP 地址，就可以根据这个 IP 找到目标机器。根据 IP 可以判断出目标机器是在本地还是在外地，显然电商网站是在外地，因此需要网关来去往外地。操作系统通过本地通信将 IP 地址发送给网关（网关的本地地址是 MAC 地址）<br><img src="https://img-blog.csdnimg.cn/20190905131333172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>于是操作系统将IP包交给了下一层，也就是MAC层。网卡再将包发出去。由于这个包里面是有MAC地址的，因而它能够到达网关。</p>
<p>网关收到包之后，会根据自己的知识，判断下一步应该怎么走。网关往往是一个路由器，到某个IP地址应该怎么走，这个叫作路由表。每个国家相当于一个局域网，在每个国家内部，都可以使用本地的地址MAC进行通信。而去往不同的国家则需要拿出 IP 头，里面有本机 IP 和目标 IP ，然后路由器会告诉你下一步怎么走。因为路由器之间也会相互沟通，到哪里应该怎么走，这种沟通的协议称为路由协议，常用的有OSPF和BGP。<br>当路由器知道这个网络包要去的地方时，就会通过目标 IP 找到目标服务器的 MAC 地址。网络包过关后，通过这个MAC地址就能找到目标服务器。</p>
<p>目标服务器发现MAC地址对上了，取下MAC头来，发送给操作系统的网络层。发现IP也对上了，就取下IP头。IP头里会写上一层封装的是TCP协议，然后将其交给传输层，即TCP层。</p>
<p>在这一层里，对于收到的每个包，都会有一个回复的包说明收到了。这个回复的包绝非这次下单请求的结果，例如购物是否成功，扣了多少钱等，而仅仅是TCP层的一个说明，即收到之后的回复。如果过一段时间还是没到，发送端的TCP层会重新发送这个包，还是上面的过程，直到有一天收到平安到达的回复。这个重试绝非你的浏览器重新将下单这个动作重新请求一次。对于浏览器来讲，就发送了一次下单请求，TCP层不断自己闷头重试。除非TCP这一层出了问题，例如连接断了，才轮到浏览器的应用层重新发送下单请求。</p>
<p>当网络包平安到达TCP层之后，TCP头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号，假设一个Tomcat，将这个包发给电商网站。<br><img src="https://img-blog.csdnimg.cn/20190905132629567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdibzgxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>服务器得到 HTTP 请求的内容进行相应的处理，然后处理完毕后就会回复一个 HTTPS的包，告诉下单成功。这个 HTTPS 包会到达浏览器，显示支付成功。</p>
]]></content>
  </entry>
  <entry>
    <title>图的相关操作及dfs和bfs详解java实现</title>
    <url>/2019/12/24/%E5%9B%BE%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%8F%8Adfs%E5%92%8Cbfs%E8%AF%A6%E8%A7%A3java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>LeetCode 中有很多关于图的dfs 和 bfs 与回溯等算法结合的算法题，例如最短路径和等。每次当我遇到这些题时，总是无法独立的写出较好的解法，我觉得这是因为我对数据结构图的理解不够，所以就重新看以前的数据结构与算法分析的书籍，以此加深自己对图的理解。</p>
<p>关于图的一些基本知识和存储结构等如果有兴趣的话可以去参考相关书籍，我这里主要写的是用邻接矩阵作为存储结构的连通图和非连通图的一些操作以及图的 dfs（深度优先搜索）和 bfs（广度优先搜索）。</p>
<p>与树的遍历操作类同，图的遍历操作的定义是，访问图中的每个顶点且每个顶点只能被访问一次。图的遍历方法主要有两种：一种是深度优先搜索。另一种是广度优先搜索。图的深度优先搜索类同于树的先根遍历，图的广度优先遍历类同于树的层序遍历。</p>
<p><strong>图的遍历算法需要考虑三点：</strong></p>
<ul>
<li>图的特点是没有首位之分，所以算法的参数需要指定访问的第一个顶点</li>
<li>对图的遍历路径可能会构成一个回路，从而造成死循环，所以算法设计要求考虑遍历路径可能出现的死循环问题</li>
<li>一个顶点可能与若干个顶点都是邻接顶点，要是一个顶点的多有邻接顶点按照某种次序被访问到</li>
</ul>
<p> <strong>连通图的深度优先遍历算法</strong><br>     在图的所有邻接顶点中，每次都在访问完当前顶点后，首先访问当前顶点的第一个邻接顶点。<br>     深度优先遍历算法可以设计为递归和非递归算法。、<br>     以下是递归算法的步骤：</p>
<ul>
<li><p>1、访问顶点 v 并标记顶点 v 已经访问</p>
</li>
<li><p>2、查找顶点 v 的第一个邻接顶点 w</p>
</li>
<li><p>3、若 w 存在，则继续指向，否则算法结束</p>
</li>
<li><p>4、若顶点 w 未被访问，则深度优先遍历递归访问顶点 w</p>
</li>
<li><p>5、查找顶点 v 的邻接顶点的下一个邻接顶点 w ，转到步骤三</p>
<p>该递归算法用到回溯的算法思想，当寻找顶点 v 的邻接顶点 w 成功时，继续进行；失败时，回溯到上一次递归调用的地方继续进行。</p>
</li>
</ul>
<p><strong>连通图的广度优先遍历算法</strong><br>    广度优先算法是一个分层搜索的过程，从指定顶点开始，按照到该顶点的顺序，以便按顺序访问这些顶点的邻接顶点，依次访问图中的其余顶点。<br>    图的广度优先遍历算法需要一个队列（或栈）来保存访问过的顶点的顺序，以便按顺序访问这些顶点的邻接顶点。其算法思想如下：</p>
<ul>
<li>1、访问初始顶点 v 并将其标记为已访问</li>
<li>2、顶点 v 入队列</li>
<li>3、若队列非空则继续执行，否则算法结束</li>
<li>4、出队列取得队头顶点 u</li>
<li>5、查找顶点 u 的第一个邻接顶点 w</li>
<li>6、若顶点 u 的邻接顶点不存在，则转到步骤三，否则循环执行：（a）若顶点 w 未被访问，则访问该顶点并标记为已访问（b）顶点入队（c）查找顶点 u 的 w 邻接顶点后的下一个邻接顶点 w ，转到步骤6</li>
</ul>
<p><strong>非连通图的遍历算法</strong><br>    对于非连通图，从图的任意一个初始顶点开始深度或广度遍历，都不能访问图中的所有顶点，这时这能访问和初始顶点联通的那些顶点。<br>    但是，对于非连通图，可以一次把每个顶点作为初始顶点进行一次深度或广度优先遍历，并根据每个顶点的访问标记来判断该顶点是否已访问过。若尚未访问过，则访问，否则跳过该顶点。这样，也能访问到非连通图中的每个顶点。</p>
<p>邻接矩阵存储结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMWGraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList list; <span class="comment">// 存储顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;  <span class="comment">// 邻接矩阵，用于存储边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">// 边的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AMWGraph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化矩阵、一维数组、边的数目</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到结点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到边的条数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结点 i 的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回两个结点对应的边的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(Object vertex)</span> </span>&#123;</span><br><span class="line">        list.add(list.size(), vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        edges[v1][v2] = <span class="number">0</span>;</span><br><span class="line">        numOfEdges--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到第一个邻接结点的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;list.size();j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据前一个邻接结点的下标来取得下一个邻接结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=v2+<span class="number">1</span>;j&lt;list.size();j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAMWGraph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结点数和边数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">4</span>, e = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 结点的标识</span></span><br><span class="line">        String[] labels =&#123;<span class="string">"V1"</span>,<span class="string">"V1"</span>,<span class="string">"V3"</span>,<span class="string">"V4"</span>&#125;;</span><br><span class="line">        AMWGraph graph=<span class="keyword">new</span> AMWGraph(n);</span><br><span class="line">        <span class="keyword">for</span>(String label:labels) &#123;</span><br><span class="line">            graph.insertVertex(label);<span class="comment">//插入结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入四条边</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"结点个数是："</span>+graph.getNumOfVertex());</span><br><span class="line">        System.out.println(<span class="string">"边的个数是："</span>+graph.getNumOfEdges());</span><br><span class="line"></span><br><span class="line">        graph.deleteEdge(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">//删除&lt;V1,V2&gt;边</span></span><br><span class="line">        System.out.println(<span class="string">"删除&lt;V1,V2&gt;边后..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"结点个数是："</span>+graph.getNumOfVertex());</span><br><span class="line">        System.out.println(<span class="string">"边的个数是："</span>+graph.getNumOfEdges());</span><br><span class="line"></span><br><span class="line">        System.out.println(graph.getNextNeighbor(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>连通图的深度优先遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连通图的深度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">depthFirstSearch</span><span class="params">(<span class="keyword">boolean</span>[] isVisited,<span class="keyword">int</span>  i)</span> </span>&#123;</span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 设置该结点已经访问</span></span><br><span class="line">        isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">                <span class="comment">// 没有被访问</span></span><br><span class="line">                depthFirstSearch(isVisited ,w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若已经被访问</span></span><br><span class="line">            w=getNextNeighbor(i, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>非连通图的深度优先遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthFirstSearch</span><span class="params">(<span class="keyword">boolean</span>[] isVisited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getNumOfVertex();i++) &#123;</span><br><span class="line">            <span class="comment">//因为对于非连通图来说，并不是通过一个结点就一定可以遍历所有结点的。</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">                depthFirstSearch(isVisited,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>连通图的广度优先遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">broadFirstSearch</span><span class="params">(<span class="keyword">boolean</span>[] isVisited,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u,w;</span><br><span class="line">        LinkedList queue=<span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问结点i</span></span><br><span class="line">        System.out.print(getValueByIndex(i)+<span class="string">"  "</span>);</span><br><span class="line">        isVisited[i]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//结点入队列</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            u=((Integer)queue.removeFirst()).intValue();</span><br><span class="line">            w=getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span>(w!=-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">                    <span class="comment">//访问该结点</span></span><br><span class="line">                    System.out.print(getValueByIndex(w)+<span class="string">"  "</span>);</span><br><span class="line">                    <span class="comment">//标记已被访问</span></span><br><span class="line">                    isVisited[w]=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//入队列</span></span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//寻找下一个邻接结点</span></span><br><span class="line">                w=getNextNeighbor(u, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>非连通图的广度优先遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadFirstSearch</span><span class="params">(<span class="keyword">boolean</span>[] isVisited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getNumOfVertex();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">                broadFirstSearch(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2019/12/24/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。<br>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p>
<p> <strong>- 分发饼干—leetcode 445</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">		 Arrays.sort(g);</span><br><span class="line">		 Arrays.sort(s);</span><br><span class="line">		 <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">int</span> cookie = <span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">while</span>(child &lt; g.length &amp;&amp; cookie &lt; s.length) &#123;</span><br><span class="line">			 <span class="keyword">if</span>(s[cookie] &gt;= g[child]) &#123;</span><br><span class="line">				 child++;</span><br><span class="line">			 &#125;</span><br><span class="line">			 cookie++;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> child;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>- 摆动序列—leetcode376（解法一）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(nums.length == <span class="number">2</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; nums[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> nums.length;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">int</span> up = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">int</span> down = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;nums.length; i++) &#123;</span><br><span class="line">			 <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">				 up = down + <span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">				 down = up + <span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>摆动序列—leetcode376（解法二:状态转换）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(nums.length == <span class="number">2</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; nums[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> nums.length;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			 <span class="keyword">switch</span>(flag) &#123;</span><br><span class="line">			 	<span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">			 		<span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">			 			count++;</span><br><span class="line">			 			flag =  <span class="number">1</span>;</span><br><span class="line">			 		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">			 			count++;</span><br><span class="line">			 			flag = <span class="number">2</span>;</span><br><span class="line">			 		&#125;</span><br><span class="line">			 		<span class="keyword">break</span>;</span><br><span class="line">			 	&#125;</span><br><span class="line">			 	<span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">			 		<span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">			 			count++;</span><br><span class="line">			 			flag = <span class="number">2</span>;</span><br><span class="line">			 		&#125;</span><br><span class="line">			 		<span class="keyword">break</span>;</span><br><span class="line">			 	&#125;</span><br><span class="line">			 	<span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">			 		<span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">			 			count++;</span><br><span class="line">			 			flag = <span class="number">1</span>;</span><br><span class="line">			 		&#125;</span><br><span class="line">			 		<span class="keyword">break</span>;</span><br><span class="line">			 	&#125;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> count;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>- 移掉K位数字—leetcode402</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//贪心算法+栈</span></span><br><span class="line">	    <span class="keyword">if</span>(k&gt;=num.length()||num.length()==<span class="number">0</span>)</span><br><span class="line">	        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">	    <span class="comment">//栈顶始终是最大值</span></span><br><span class="line">	    Stack&lt;Integer&gt;stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	    stack.push(num.charAt(<span class="number">0</span>)-<span class="string">'0'</span>);</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num.length();i++) &#123;</span><br><span class="line">	        <span class="keyword">int</span> now=num.charAt(i)-<span class="string">'0'</span>;</span><br><span class="line">	        <span class="comment">//可能好几个值都比当前值大，那么我们就在k允许的情况下，去去除它。</span></span><br><span class="line">	        <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;k&gt;<span class="number">0</span>&amp;&amp;now&lt;stack.peek())&#123;</span><br><span class="line">	             stack.pop();</span><br><span class="line">	             k--;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">//不等于0可以添加进去,</span></span><br><span class="line">	        <span class="comment">//等于0，栈不为空可以填进去，</span></span><br><span class="line">	        <span class="keyword">if</span>(now!=<span class="number">0</span>||!stack.isEmpty()) &#123;</span><br><span class="line">	             stack.push(now);</span><br><span class="line">	           &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">//56789这种情况，前面一直比后面小，那就去除栈顶，谁让栈顶最大</span></span><br><span class="line">	        <span class="keyword">while</span>(k&gt;<span class="number">0</span>) &#123;</span><br><span class="line">	            k--;</span><br><span class="line">	            stack.pop();</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">//10，1(当now=0时，满足条件，去掉1，但now为0，且为空。)</span></span><br><span class="line">	        <span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">	            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">	        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">	        <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">	            sb.append(stack.pop());</span><br><span class="line">	        <span class="comment">//从后往前添加所以我们要逆序</span></span><br><span class="line">	        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>- 跳跃游戏–leetcode55</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	         <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">			 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">				 index[i] = nums[i] + i;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">int</span> jump = <span class="number">0</span>;</span><br><span class="line">			 <span class="keyword">int</span> max_index = index[<span class="number">0</span>];</span><br><span class="line">			 <span class="keyword">while</span>(jump &lt; index.length &amp;&amp; jump &lt;= max_index) &#123;</span><br><span class="line">				 <span class="keyword">if</span>(max_index &lt; index[jump]) &#123;</span><br><span class="line">					 max_index = index[jump];</span><br><span class="line">				 &#125;</span><br><span class="line">				 jump++;</span><br><span class="line">				 <span class="keyword">if</span>(jump == index.length) &#123;</span><br><span class="line">					 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				 &#125;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>- 跳跃游戏 II–leetcode45</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">int</span> current_max_index = nums[<span class="number">0</span>];</span><br><span class="line">		 <span class="keyword">int</span> pre_max_index = nums[<span class="number">0</span>];</span><br><span class="line">		 <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			 <span class="keyword">if</span>(current_max_index &lt; i) &#123;</span><br><span class="line">				 count++;</span><br><span class="line">				 current_max_index = pre_max_index;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">if</span>(pre_max_index &lt; nums[i] + i) &#123;</span><br><span class="line">				 pre_max_index = nums[i] + i;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> count;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>- 用最少数量的箭引爆气球–leetcode452</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(points.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span> points.length;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="comment">// 按照区间终点进行排序</span></span><br><span class="line">		 Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] point1, <span class="keyword">int</span>[] point2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (point1[<span class="number">1</span>] != point2[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> point1[<span class="number">1</span>] - point2[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="keyword">return</span> point1[<span class="number">0</span>] - point2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			 </span><br><span class="line">		 &#125;);</span><br><span class="line">		 <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">			 <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; end) &#123;</span><br><span class="line">				 <span class="comment">// 多用一支箭</span></span><br><span class="line">				 count++;</span><br><span class="line">				 end = points[i][<span class="number">1</span>];</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> count;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>深入理解Cookie</title>
    <url>/2019/12/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Cookie/</url>
    <content><![CDATA[<p>Session 与 Cookie 的使用是一个既简单又复杂的问题，简单是因为它们本身只是 HTTP 中的一个配置项，在 Servlet 规范中只是对应到一个类而已；复杂则是因为当系统达到需要用到很多的 Cookie 时，我们需要考虑 HTTP 对 Cookie 数量和大小的限制。 Session 也会有同样的问题，当一个应用系统有几百台服务器时，怎样能解决 Session 在多台服务器之间共享的问题呢？</p>
<p>Session 与 Cookie 都是为了保持用户与后端服务器的交互状态。它们各自有其优缺点，例如：使用 Cookie 来传递信息时，随着 Cookie 个数的增多和访问量的增加，它占用的网络带宽也会增大，所以有大访问量是希望用 Session ，但是 Session 的致命弱点是不容易在多台服务器之间共享，这限制了 Session 的使用。</p>
<ul>
<li><p>理解Cookie<br>Cookie 的作用通俗的说当一个用户通过 HTTP 访问一个服务器时，这个服务器会将一些 Key/Value 键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器时，数据又被完整地待会给服务器。</p>
<p> 由于 HTTP 是一种无状态协议，当用户的一次请求访问结束后，后端服务器无法主导下一次来访问的还是不是上一个用户。而当在一个很短的时间间隔内，如果一个用户相关的数据被频繁访问，则可以针对这个数据做缓存，这样可以大大提高数据的访问性能。Cookie 的作用正是如此，由于是同一个客户端发出的请求，每次发出的请求都会带有第一次访问时服务端设置的信息，这样服务器就可以根据 Cookie 值来划分访问的用户了。</p>
<p> Cookie 用一些常见的属性项：</p>
<pre><code>NAME=VALUE    键值对，可以设置要保存的 Key/Value
Expires                过期时间，在设置的某个时间点后该 Cookie 就会失效
Domain                生成该 Cookie 的域名
Path                        该 Cookie 是在当前哪个路径下生成的
Secure                    如果设置了这个属性，那么只会在SSH连接时才会回传该 Cookie</code></pre></li>
</ul>
<ul>
<li>Cookie 如何工作<br>  当我们用如下方式创建 Cookie 时：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String getCookie(Cookie[] cookies, String key) &#123;</span><br><span class="line">	if(cookies !&#x3D; null) &#123;</span><br><span class="line">		for(Cookie cookie : cookies) &#123;</span><br><span class="line">			if(cookie.getName().equals(key)) &#123;</span><br><span class="line">				return cookie.getValue();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void doGet(HttpServletRequest request,HttpServletResponse response) </span><br><span class="line">			throws IOException,ServletException &#123;</span><br><span class="line">		Cookie[] cookies &#x3D; request.getCookies();</span><br><span class="line">		String userName &#x3D; getCookie(cookies,&quot;userName&quot;);</span><br><span class="line">		String userAge &#x3D; getCookie(cookies,&quot;userAge&quot;);</span><br><span class="line">		if(userName &#x3D;&#x3D; null) &#123;</span><br><span class="line">			response.addCookie(new Cookie(&quot;userName&quot;,&quot;helloworld&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">		if(userAge &#x3D;&#x3D; null) &#123;</span><br><span class="line">			response.addCookie(new Cookie(&quot;userAge&quot;,&quot;18&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">		response.getHeader(&quot;Set-Cookie&quot;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>那么 Cookie 是如何加到 HTTP 的 Header 中的呢？下面来看一下 Tomcat是如何调用 addCookie() 方法的。<br>通过查找资料可以看出，真正构建 Cookie 是在 org.apache.catalina.Response 类中完成的，调用 generateCookieString() 方法将 Cookie 对象构造成一个键值对形式的字符串，然后将这个字符串命名为 Set-Cookie 添加到 MineHeader中。</p>
<p>以上讲述了在服务端如何创建 Cookie ，下面看一下如何从客户端获取 Cookie。<br>    当我们请求某个 URL 路径时，浏览器会根据这个 URL 路径健符合条件的 Cookie 放在 Request 请求头中传回给服务器，服务器通过 request.getCookies() 来取得所有的 Cookie。</p>
<ul>
<li>使用 Cookie 的限制<br>  Cookie 是 HTTP 头中的一个字段，虽然 HTTP 本身对这个字段并没有多少限制，但是 Cookie 最终还是存储在浏览器中，不同的浏览器对 Cookie 的存储的大小和数量都有一些限制。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
